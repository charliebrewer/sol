(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
module.exports = function() {
	var module = {};
	
	module.getData = function(id, callback) {
		callback(null);
	};
	
	module.setData = function(id, data, callback) {
		callback(false);
	};
	
	module.addData = function(id, data, callback) {
		callback(false);
	};
	
	module.delData = function(id, callback) {
		callback(false);
	};
	
	return module;
};

},{}],3:[function(require,module,exports){
const DataSources = require('./DataSources');

const DaoFactoryLocal = require('./DaoFactoryLocal');
const DaoFactoryMemcache = require('./DaoFactoryMemcache');
const DaoFactoryServer = require('./DaoFactoryServer');
const DaoFactoryDB = require('./DaoFactoryDB');

module.exports = function() {
	var module = {};
	
	/**
	 * Returns a dao factory of the associated source type.
	 */
	module.getDaoFactory = function(sourceType) {
		switch(sourceType) {
			case DataSources.SOURCE_LOCAL:
				return DaoFactoryLocal();
			break;
			
			case DataSources.SOURCE_MEMCACHE:
				return DaoFactoryMemcache();
			break;
			
			case DataSources.SOURCE_SERVER:
				return DaoFactoryServer();
			break;
			
			case DataSources.SOURCE_DB:
				return DaoFactoryDB();
			break;
		}
		
		throw "Unhandled factory type: " + sourceType;
	};
	
	return module;
};

},{"./DaoFactoryDB":1,"./DaoFactoryLocal":4,"./DaoFactoryMemcache":1,"./DaoFactoryServer":5,"./DataSources":7}],4:[function(require,module,exports){
const DataSources = require('./DataSources');

const LocalDao = require('./LocalDao');

module.exports = function() {
	var module = {};
	
	module.sourceType = DataSources.SOURCE_LOCAL;
	
	module.getDao = function(daoType) {
		// We don't care about daoType here, all local daos are the same.
		return LocalDao();
	};
	
	return module;
};

},{"./DataSources":7,"./LocalDao":8}],5:[function(require,module,exports){
const DataSources = require('./DataSources');

const DefCelBodiesDaoServer = require('./ServerDaos/DefCelBodiesDaoServer');
const PlayerDaoServer = require('./ServerDaos/PlayerDaoServer');

module.exports = function() {
	var module = {};
	
	module.sourceType = DataSources.SOURCE_SERVER;
	
	module.getDao = function(daoType) {
		switch(daoType) {
			case DataSources.DAO_PLAYER:
				return PlayerDaoServer();
			break;
			
			case DataSources.DAO_CEL_BODIES:
				return DefCelBodiesDaoServer();
			break;
		}
	};
	
	return module;
};

},{"./DataSources":7,"./ServerDaos/DefCelBodiesDaoServer":9,"./ServerDaos/PlayerDaoServer":10}],6:[function(require,module,exports){
const DataSources = require('./DataSources');
const DaoFactoryFactory = require('./DaoFactoryFactory');

/**
 * DataBox facade for requesting data from an arbitrary number of sources.
 *
 * Sources are bitmasks of DataSources.SOURCE_* that inform the DataBox
 * where to request data and where to write data.
 *
 * Cache management is handled automatically when reading and writing data.
 * While it is not recommended, you can define custom methods in a
 * particular DAO and request that DAO through the DataBox to call the
 * functions on it. Be sure to flush cache if the functions change state.
 */
module.exports = function() {
	var module = {};
	
	module.getDataBoxServerStandard = function() {
		return module.getDataBox(
			DataSources.SOURCE_LOCAL | DataSources.SOURCE_MEMCACHE | DataSources.SOURCE_DB,
			DataSources.SOURCE_DB,
			DataSources.SOURCE_LOCAL | DataSources.SOURCE_MEMCACHE
		);
	};
	
	module.getDataBoxServerNoWrite = function() {
		return module.getDataBox(
			DataSources.SOURCE_LOCAL | DataSources.SOURCE_MEMCACHE | DataSources.SOURCE_DB,
			DataSources.SOURCE_LOCAL,
			DataSources.SOURCE_NONE
		);
	};
	
	module.getDataBoxClientStandard = function() {
		return module.getDataBox(
			DataSources.SOURCE_LOCAL | DataSources.SOURCE_SERVER,
			DataSources.SOURCE_NONE,
			DataSources.SOURCE_LOCAL
		);
	};
	
	module.getDataBox = function(readSources, writeSources, cacheSources) {
		// DAO Factory bitmasks
		var _readSources  = parseInt(readSources);
		var _writeSources = parseInt(writeSources);
		var _cacheSources = parseInt(cacheSources);
		if(isNaN(_readSources) || isNaN(_writeSources) || isNaN(_cacheSources))
			throw "Invalid DataBox sources";
		
		if(0 != (_writeSources & DataSources.SOURCE_DB) && 0 == (_cacheSources & DataSources.SOURCE_MEMCACHE))
			throw "Cannot create data box that writes to db and doesn't clear memcache";
		
		var _daos = {
			_daos : {},
			
			getDao : function(sourceType, daoType) {
				return this._daos[this.getKey(sourceType, daoType)];
			},
			
			setDao : function(sourceType, daoType, dao) {
				this._daos[this.getKey(sourceType, daoType)] = dao;
			},
			
			clrDao : function(sourceType, daoType) {
				delete this._daos[this.getKey(sourceType, daoType)];
			},
			
			getKey : function(sourceType, daoType) {
				return sourceType + '_' + daoType;
			}
		};
		
		/**
		 * Method to return a specific concrete dao. This function is exposed
		 * so that custom behavior can be added to a dao and referenced later.
		 */
		var _getDao = function(sourceType, daoType) {
			if(0 == (sourceType & (_readSources | _writeSources | _cacheSources)))
				throw "Cannot retrieve dao not associated with this DataBox";
			
			var dao = _daos.getDao(sourceType, daoType);
			
			if(undefined == dao) {
				dao = DaoFactoryFactory().getDaoFactory(sourceType).getDao(daoType);
				_daos.setDao(sourceType, daoType, dao);
			}
			
			return dao;
		};
		
		// sources, order of sources, function to call, set cache or clear cache
		
		var _getData = function(prevSourceType, daoType, id, callback) {
			var sourceType = DataSources.nextSourceType(prevSourceType, _readSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				callback(null);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.getData(id, function(output) {
				if(null != output) {
					_cacheData(sourceType, daoType, id, output, function() {
						callback(output);
					});
					
					return;
				}
				
				_getData(sourceType, daoType, id, callback);
			});
		};
		
		var _setData = function(prevSourceType, daoType, id, data, callback) {
			var sourceType = DataSources.nextSourceType(prevSourceType, _writeSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				_clearCache(DataSources.SOURCE_NONE, daoType, id, callback);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.setData(id, data, function() {
				_setData(sourceType, daoType, id, data, callback);
			});
		};
		
		var _addData = function(prevSourceType, daoType, id, data, callback) {
			var sourceType = DataSources.nextSourceType(prevSourceType, _writeSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				_clearCache(DataSources.SOURCE_NONE, daoType, id, callback);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.addData(id, data, function() {
				_addData(sourceType, daoType, id, data, callback);
			});
		};
		
		var _delData = function(prevSourceType, daoType, id, callback) {
			var sourceType = DataSources.nextSourceType(prevSourceType, _writeSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				_clearCache(DataSources.SOURCE_NONE, daoType, id, callback);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.delData(id, function() {
				_delData(sourceType, daoType, id, callback);
			});
		};
		
		var _cacheData = function(prevSourceType, daoType, id, data, callback) {
			var sourceType = DataSources.prevSourceType(prevSourceType, _cacheSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				callback(true);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.setData(id, data, function() {
				_cacheData(sourceType, daoType, id, data, callback);
			});
		};
		
		var _clearCache = function(prevSourceType, daoType, id, callback) {
			var sourceType = DataSources.nextSourceType(prevSourceType, _cacheSources);
			
			if(DataSources.SOURCE_NONE == sourceType) {
				callback(true);
				return;
			}
			
			var dao = _getDao(sourceType, daoType);
			
			dao.delData(id, function() {
				_clearCache(sourceType, daoType, id, callback);
			});
		};
		
		return {
			getData : function(daoType, id, callback) {
				_getData(DataSources.SOURCE_NONE, daoType, id, callback);
			},
			
			setData : function(daoType, id, data, callback) {
				_setData(DataSources.SOURCE_NONE, daoType, id, data, callback);
			},
			
			addData : function(daoType, id, data, callback) {
				_addData(DataSources.SOURCE_NONE, daoType, id, data, callback);
			},
			
			delData : function(daoType, id, callback) {
				_delData(DataSources.SOURCE_NONE, daoType, id, callback);
			},
			
			clearCache : function(daoType, id, callback) {
				_clearCache(DataSources.SOURCE_NONE, daoType, id, callback);
			},
		};
	};
	
	return module;
};

},{"./DaoFactoryFactory":3,"./DataSources":7}],7:[function(require,module,exports){
module.exports = {
	SOURCE_NONE     : 0,
	SOURCE_LOCAL    : 1,
	SOURCE_MEMCACHE : 2,
	SOURCE_SERVER   : 4,
	SOURCE_DB       : 8,
	SOURCE_ALL      : 255,
	
	/**
	 * Returns the next numerically higher data source contained in the sources
	 * bitmask. Returns SOURCE_NONE when there are no more sources.
	 */
	nextSourceType : function(currFactory, sources) {
		if(0 == (sources & ~Math.max(0, currFactory * 2 - 1)))
			return this.SOURCE_NONE;
		
		// Guaranteed to have another source here
		var nextFactory;
		
		for(let i = 0; i < this.SOURCE_ALL; i++) {
			nextFactory = ((sources >> i) & 1) << i;
			if(0 != nextFactory && nextFactory > currFactory)
				return nextFactory;
		}
		
		throw "Failed to find next factory";
	},
	
	/**
	 * Returns the next numerically lower data source contained in the sources
	 * bitmask. Returns SOURCE_NONE when there are no more sources.
	 */
	prevSourceType : function(currFactory, sources) {
		if(this.SOURCE_NONE == currFactory)
			currFactory = this.SOURCE_ALL + 1;
		
		do {
			currFactory /= 2;
			if(0 != (sources & currFactory))
				return currFactory;
		} while(currFactory > 1);
		
		return this.SOURCE_NONE;
	},
	
	DAO_PLAYER: 1,
	DAO_CEL_BODIES: 2
};

},{}],8:[function(require,module,exports){
const BaseDao = require('./BaseDao');

module.exports = function() {
	var dao = BaseDao();
	
	var _data = {};
	
	dao.getData = function(id, callback) {
		if(undefined != _data[id]) {
			callback(_data[id]);
			return;
		}
		
		callback(null);
	};
	
	dao.setData = function(id, data, callback) {
		_data[id] = data;
		
		callback(true);
	};
	
	dao.addData = function(id, data, callback) {
		dao.getData(id, function(output) {
			if(null != output)
				callback(false);
			else {
				dao.setData(id, data, callback);
			}
		});
	};
	
	dao.delData = function(id, callback) {
		if(undefined == _data[id])
			callback(false);
		else {
			delete _data[id];
			
			callback(true);
		}
	};
	
	return dao;
};

},{"./BaseDao":2}],9:[function(require,module,exports){
const BaseDao = require('../BaseDao');

module.exports = function() {
	var dao = BaseDao();
	
	dao.getData = function(id, callback) {
		SolGame.models.getDefinitionsData(function(defData) {
			callback(defData.celestialBodies);
		});
	};
	
	return dao;
};

},{"../BaseDao":2}],10:[function(require,module,exports){
const BaseDao = require('../BaseDao');

module.exports = function() {
	var dao = BaseDao();
	
	dao.getData = function(id, callback) {
		SolGame.models.getPlayerData(function(playerData) {
			callback(playerData.playerRecord);
		});
	};
	
	return dao;
};

},{"../BaseDao":2}],11:[function(require,module,exports){
module.exports = function() {
	var module = {};
	
	module.ITEM_TYPE_NOTHING     = 0;
	module.ITEM_TYPE_BUCKET      = 1;
	module.ITEM_TYPE_CREDITS     = 2;
	module.ITEM_TYPE_SHIP        = 3;
	module.ITEM_TYPE_COMMODITY   = 4;
	module.ITEM_TYPE_SHIP_MODULE = 5;
	module.ITEM_TYPE_R_CREDITS   = 6;
	
	module.createBucketFromDef = function(defBucket, defBucketItems) {
		var bucket = module.createEmptyBucket();
		
		bucket.id = defBucket['bucket_id'];
		bucket.name = defBucket['name'];
		
		defBucketItems.forEach(function(defBucketItem) {
			if(defBucketItem['bucket_id'] != defBucket['bucket_id'])
				console.log("Bucket item bucket id " + defBucketItem['bucket_id'] + " doesn't match def bucket id " + defBucket['bucket_id']);
			else
				bucket.modifyContents(defBucketItem['item_type'], defBucketItem['item_id'], defBucketItem['item_quantity']);
		});
		
		return bucket;
	};
	
	module.createBucketFromString = function(bucketItemsJson) {
		var bucket = module.createEmptyBucket();
		
		var bucketItems = JSON.parse(bucketItemsJson);
		
		// This logic is duplicated in bucket.forEachItem, but I didn't want to
		// hack a bucket together to be able to iterate over its items
		Object.getOwnPropertyNames(bucketItems).forEach(function(itemType) {
			Object.getOwnPropertyNames(bucketItems[itemType]).forEach(function(itemId) {
				bucket.modifyContents(itemType, itemId, bucketItems[itemType][itemId]);
			});
		});
		
		return bucket;
	};
	
	module.createBucketFromBucket = function(bucket) {
		var copy = module.createEmptyBucket();
		
		copy.id = bucket.id;
		copy.name = bucket.name;
		copy.allowNegatives = bucket.allowNegatives;
		
		bucket.forEachItem(function(itemType, itemId, itemQuantity) {
			copy.modifyContents(itemType, itemId, itemQuantity);
		});
		
		return copy;
	};
	
	module.createEmptyBucket = function() {
		var bucket = {};
		
		bucket.id = 0;
		bucket.name = "Bucket";
		bucket.allowNegatives = false;
		bucket.items = {};
		
		/**
		 * The primary way that a bucket's contents are modified. This will
		 * potentially fail when adding negative quantities.
		 *
		 * @return bool If the bucket was modified or not.
		 */
		bucket.modifyContents = function(itemType, itemId, itemQuantity) {
			itemType     = parseInt(itemType).toString();
			itemId       = parseInt(itemId).toString();
			itemQuantity = parseInt(itemQuantity);
			
			if(0 == itemQuantity)
				return false;
			
			if(0 < itemQuantity || bucket.allowNegatives) {
				if(!Object.getOwnPropertyNames(bucket.items).includes(itemType))
					bucket.items[itemType] = {};
				
				if(!Object.getOwnPropertyNames(bucket.items[itemType]).includes(itemId))
					bucket.items[itemType][itemId] = 0;
			} else {
				if(!Object.getOwnPropertyNames(bucket.items).includes(itemType))
					return false;
				
				if(!Object.getOwnPropertyNames(bucket.items[itemType]).includes(itemId))
					return false;
			}
			
			if(0 > (bucket.items[itemType][itemId] + itemQuantity) && !bucket.allowNegatives)
				return false;
			
			bucket.items[itemType][itemId] += itemQuantity;
			
			if(0 == bucket.items[itemType][itemId])
				bucket.removeItem(itemType, itemId);
			
			return true;
		};
		
		bucket.addBucketContents = function(otherBucket) {
			otherBucket.forEachItem(function(itemType, itemId, itemQuantity) {
				bucket.modifyContents(itemType, itemId, itemQuantity);
			});
		};
		
		/**
		 * Removes ALL of a given item from this bucket.
		 *
		 * @return bool If an item was removed.
		 */
		bucket.removeItem = function(itemType, itemId) {
			var retVal = false;
			
			if(undefined != bucket.items[itemType]) {
				if(undefined != bucket.items[itemType][itemId]) {
					delete bucket.items[itemType][itemId];
					retVal = true;
				}
				
				if(0 == Object.getOwnPropertyNames(bucket.items[itemType]).length) {
					delete bucket.items[itemType];
					retVal = true;
				}
			}
			
			return retVal;
		};
		
		bucket.getItemQuantity = function(itemType, itemId) {
			if(undefined != bucket.items[itemType]) {
				if(undefined != bucket.items[itemType][itemId]) {
					return bucket.items[itemType][itemId];
				}
			}
			
			return 0;
		};
		
		/**
		 * Function to iterate of the contents of this bucket. Calls callback
		 * with itemType, itemId, and itemQuantity parameters.
		 */
		bucket.forEachItem = function(callback) {
			Object.getOwnPropertyNames(bucket.items).forEach(function(itemType) {
				Object.getOwnPropertyNames(bucket.items[itemType]).forEach(function(itemId) {
					callback(itemType, itemId, bucket.items[itemType][itemId]);
				});
			});
		};
		
		bucket.setAllowNegatives = function(allow) {
			if(allow) {
				bucket.allowNegatives = true;
			} else {
				// Need to clean out negative values, create a copy so we can iterate over the items cleanly
				var copy = module.createBucketFromBucket(bucket);
				
				copy.forEachItem(function(itemType, itemId, itemQuantity) {
					if(0 >= itemQuantity)
						bucket.removeItem(itemType, itemId);
				});
				
				bucket.allowNegatives = false;
			}
		};
		
		/**
		 * Sums the quantities of all items or just the items that have a type
		 * which is contained in the itemTypeArr parameter.
		 */
		bucket.itemQuantitySum = function(itemTypeArr = null) {
			var sum = 0;
			
			bucket.forEachItem(function(itemType, itemId, itemQuantity) {
				if(null == itemTypeArr || itemTypeArr.includes(itemType))
					sum += itemQuantity;
			});
			
			return sum;
		};
		
		bucket.numUniqueItems = function() {
			var sum = 0;
			
			bucket.forEachItem(function(itemType, itemId, itemQuantity) {
				sum++;
			});
			
			return sum;
		};
		
		/**
		 * Function to generate the JSON object associated with this bucket's
		 * contents. Does not encapsulate the other properties of the bucket.
		 * The output of this function should be what is passed into the
		 * createBucketFromString constructor.
		 */
		bucket.getItemsString = function() {
			return JSON.stringify(bucket.items);
		};
		
		return bucket;
	};
	
	return module;
};

},{}],12:[function(require,module,exports){
module.exports = {
	DATA_ANY:   0,
	DATA_BOOL:  1,
	DATA_INT:   2,
	DATA_FLOAT: 3,
	DATA_STR:   4,
	DATA_ARR:   5,
	DATA_OBJ:   6,
	
	/**
	 * Function to compare an object against a template. Builds a new object
	 * based on the template and returns it.
	 *
	 * @param obj The object to be validated.
	 * @param template Template object to compare against. Keys in the template
	 *     correspond to named keys expected in the object, and the values of each
	 *     key map to an object with the following keys.
	 *       type: ObjectValidator.DATA_INT - Required
	 *       optional: false - Allows a field to be optional, defaults to false
	 *       template: {} - Another valid template, used for object types and arrays containing objects
	 *       arrType: ObjectValidator.DATA_INT - The type of elements in an array
	 */
	cleanObj: function(obj, template) {
		if('object' != typeof obj || Array.isArray(obj))
			throw "Not validating object";
		
		var retObj = {};
		
		Object.keys(template).forEach(function(key) {
			if(undefined == obj[key]) {
				if(undefined != template[key].optional && template[key].optional)
					return;
				
				throw "Object doesn't have key: " + key;
			}
			
			if(module.exports.DATA_ANY == template[key].type) {
				retObj[key] = obj[key];
			} else if(module.exports.DATA_OBJ == template[key].type) {
				if('object' != typeof obj[key])
					throw "Key was not object: " + key;
				
				retObj[key] = module.exports.cleanObj(obj[key], template[key].template);
			} else if(module.exports.DATA_ARR == template[key].type) {
				if(!Array.isArray(obj[key]))
					throw "Key was not array: " + key;
				
				if(module.exports.DATA_ARR == template[key].arrType)
					throw "Arrays within arrays not supported";
					
				retObj[key] = [];
				
				obj[key].forEach(function(val) {
					if(module.exports.DATA_OBJ == template[key].arrType)
						retObj[key].push(module.exports.cleanObj(val, template[key].template));
					else
						retObj[key].push(module.exports.cleanData(val, template[key].arrType));
				});
			} else {
				// Assumed primitive data type
				retObj[key] = module.exports.cleanData(obj[key], template[key].type);
			}
		});
		
		return retObj;
	},
	
	/**
	 * Function to clean primitive data. Not used for arrays and objects.
	 *
	 * @param data The data to be cleaned
	 * @param type The type of data expected, DATA_*
	 *
	 * @return Primitive data type
	 */
	cleanData: function(data, type) {
		var retData;
		
		switch(type) {
			case module.exports.DATA_BOOL:
				retData = !!data;
			break;
			
			case module.exports.DATA_INT:
				retData = parseInt(data, 10);
				
				if(isNaN(retData))
					throw "Expected int, got NaN";
			break;
			
			case module.exports.DATA_FLOAT:
				retData = parseFloat(data);
				
				if(isNaN(retData))
					throw "Expected float, got NaN";
				if(!isFinite(retData))
					throw "Received infinite value";
			break;
			
			case module.exports.DATA_STR:
				retData = data + '';
			break;
			
			default:
				throw "Unhandled primitive data type: " + type;
			break;
		}
		
		return retData;
	},
};

},{}],13:[function(require,module,exports){
const DataSources = require('../data/DataSources');
const PathData = require('./PathData');

module.exports = {
	SOL_ID: 1, // ID of the sun in the db
	
	MAPOBJ_CELBODY: 1,
	MAPOBJ_STATION: 2,
	MAPOBJ_ANOMALY: 3,
	
	ANOM_UNKNOWN:       0,
	ANOM_SHIP:          1,
	ANOM_COMMUNICATION: 2, // Distress calls, regular comms
	ANOM_EXPLOSION:     3, // Weapons fire, ship destruction
	ANOM_CARGO:         4, // Items
	
	MapObj: function(type, id) {
		this.type      = type;
		this.id        = id;
		this.imgUrl    = '';
		this.active    = true;
		this.path      = new PathData.PathObj();
	},
	
	SystemMap : function() {
		var _mapObjs = [];
		
		this.forActiveMapObj = function(callback) {
			_mapObjs.forEach(function(e) {
				if(e.active)
					callback(e);
			});
		};
		
		this.forAllMapObj = function(callback) {
			_mapObjs.forEach(function(e) {
				callback(e);
			});
		};
		
		this.addMapObj = function(mapObj) {
			if(undefined != _mapObjs.find(e => e.type == mapObj.type && e.id == mapObj.id))
				throw "Adding map obj that already exists. type " + mapObj.type + " id: " + mapObj.id;
			
			if(PathData.PATH_ORBIT == mapObj.path.type) {
				mapObj.path.data.parentPos = _mapObjs.find(e => module.exports.MAPOBJ_CELBODY == e.type && e.id == mapObj.path.data.parentId).path.pos;
				
				if(undefined == mapObj.path.data.parentPos)
					throw "Could not find parent. ID: " + mapObj.path.data.parentId;
			}
			
			_mapObjs.push(mapObj);
		},
		
		this.removeAnomaly = function(id) {
			var index;
			
			for(index = 0; index < _mapObjs.length; index++) {
				if(_mapObjs[index].type == module.exports.MAPOBJ_ANOMALY && _mapObjs[index].id == id)
					break;
			}
			
			if(index < _mapObjs.length)
				_mapObjs.splice(index, 1);
		};
		
		this.updateAllPos = function(timeMs) {
			this.forActiveMapObj(function(mapObj) {
				mapObj.path.updatePos(timeMs);
			});
		};
	},
	
	/**
	 * Function to build a system map object with celestial bodies and stations
	 * included. Also fetches anomaly data for the player as well as their own
	 * route if it exists.
	 *
	 * @return SystemMap
	 */
	buildSystemMap: function(dataBox, callback) {
		var systemMap = new this.SystemMap();
		
		var mapObj;
		
		dataBox.getData(DataSources.DAO_CEL_BODIES, 0, function(defCelBodies) {
			// First we add the sun
			var defSol = defCelBodies.find(e => module.exports.SOL_ID == e.celestial_body_id);
			
			mapObj = new module.exports.MapObj(module.exports.MAPOBJ_CELBODY, defSol.celestial_body_id);
			mapObj.imgUrl = defSol.img_url;
			mapObj.path = new PathData.PathObj();
			mapObj.path.type = PathData.PATH_POINT; // Sun doesn't move
			
			systemMap.addMapObj(mapObj);
			
			var bodyArr = [];
			bodyArr.push(defSol.celestial_body_id);
			
			for(let i = 0; i < bodyArr.length; i++) {
				defCelBodies.filter(e => e.parent_body_id == bodyArr[i]).forEach(function(defCelBody) {
					bodyArr.push(defCelBody.celestial_body_id);
					
					mapObj = new module.exports.MapObj(module.exports.MAPOBJ_CELBODY, defCelBody.celestial_body_id);
					mapObj.imgUrl = defCelBody.img_url;
					
					mapObj.path = new PathData.getPath(PathData.PATH_ORBIT, {
						distanceFromParent: defCelBody.distance_from_parent,
						orbitalPeriodHours: defCelBody.distance_from_parent * 50,
						thetaOffsetDeg: 0,
						parentId: defCelBody.parent_body_id
					});
					
					systemMap.addMapObj(mapObj);
				});
			}
			
			callback(systemMap);
		});
	}
};

},{"../data/DataSources":7,"./PathData":16}],14:[function(require,module,exports){
var OrbitalMechanics = require('./OrbitalMechanics');
var Bezier = require('bezier-js');
var Victor = require('victor');

/**
 * This class is a helper for calculating navigational data between celestial
 * bodies. It deals with translating a path into a bezier curve, with getting
 * a position on a bezier curve, escape velocities and route pathfinding.
 */
module.exports = function() {
	var module = {};
	
	module.DESTINATION_TYPE_UNKNOWN = 0;
	module.DESTINATION_TYPE_STATION = 1; // ID is station ID
	module.DESTINATION_TYPE_ROUTE   = 2; // ID route ID
	module.DESTINATION_TYPE_ORBIT   = 3; // ID is celestial_body_id
	
	module.LOCATION_TYPE_UNKNOWN  = 0;
	module.LOCATION_TYPE_STATION  = 1;
	module.LOCATION_TYPE_ROUTE    = 2;
	module.LOCATION_TYPE_DOCKING  = 3;
	
	module.MAX_ROUTE_SEGMENTS = 10;
	module.MAX_ROUTE_TIME_SEC = 20;//1440;
	module.MAX_ROUTE_SEG_TURN_DEG = 60;
	
	/*
	The following several functions deal with the creation of "large" and
	"small" routes. The principal difference between large and small is the use
	of Bezier objects or the simple data points.
	
	Small segments are created with basic data, and large segments are created
	with small segments. There is a single function to convert a large route to
	a small route, since we mostly deal with large segments and only convert to
	small for transport or data storage.
	*/
	
	module.getRouteSegSml = function(
		startCrd, endCrd, routeControl1X, routeControl1Y, routeControl2X, routeControl2Y,
		speedControl1X, speedControl1Y, speedControl2X, speedControl2Y, fuelBurn
	) {
		var routeSegSml = {};
		
		routeSegSml.sCrd = startCrd;
		routeSegSml.eCrd = endCrd;
		routeSegSml.rc1  = {x : routeControl1X, y : routeControl1Y};
		routeSegSml.rc2  = {x : routeControl2X, y : routeControl2Y};
		routeSegSml.sc1  = {x : speedControl1X, y : speedControl1Y};
		routeSegSml.sc2  = {x : speedControl2X, y : speedControl2Y};
		routeSegSml.fb   = fuelBurn;
		
		return routeSegSml;
	};
	
	module.getRouteSegLrg = function(routeSegSml) {
		var routeSegLrg = {};
		
		routeSegLrg.sCrd = routeSegSml.sCrd;
		routeSegLrg.eCrd = routeSegSml.eCrd;
		
		routeSegLrg.posCurve = new Bezier(
			routeSegSml.sCrd.pos.x, routeSegSml.sCrd.pos.y,
			routeSegSml.rc1.x, routeSegSml.rc1.y,
			routeSegSml.rc2.x, routeSegSml.rc2.y,
			routeSegSml.eCrd.pos.x, routeSegSml.eCrd.pos.y,
		);
		
		routeSegLrg.spdCurve = new Bezier(
			0,0,
			routeSegSml.sc1.x, routeSegSml.sc1.y,
			routeSegSml.sc2.x, routeSegSml.sc2.y,
			1,1
		);
		
		routeSegLrg.fb = routeSegSml.fb;
		
		return routeSegLrg;
	};
	
	module.getRouteSml = function(routeId, destinationType, destinationId, plrShipId, routeSegsSml) {
		var routeSml = {};
		
		routeSml.id = routeId;
		routeSml.dt = destinationType;
		routeSml.di = destinationId;
		routeSml.ps = plrShipId;
		routeSml.rd = routeSegsSml;
		
		return routeSml;
	};
	
	module.getRouteLrg = function(routeSml) {
		var routeLrg = {};
		
		routeLrg.routeId         = routeSml.id;
		routeLrg.destinationType = routeSml.dt;
		routeLrg.destinationId   = routeSml.di;
		routeLrg.plrShipId       = routeSml.ps;
		routeLrg.routeSegs       = [];
		
		routeSml.rd.forEach(function(routeSegSml) {
			routeLrg.routeSegs.push(module.getRouteSegLrg(routeSegSml));
		});
		
		return routeLrg;
	};
	
	module.convertRouteLrgToSml = function(routeLrg) {
		var routeSegsSml = [];
		
		routeLrg.routeSegs.forEach(function(routeSegLrg) {
			routeSegsSml.push(module.getRouteSegSml(
				routeSegLrg.sCrd,
				routeSegLrg.eCrd,
				routeSegLrg.posCurve.points[1].x,
				routeSegLrg.posCurve.points[1].y,
				routeSegLrg.posCurve.points[2].x,
				routeSegLrg.posCurve.points[2].y,
				routeSegLrg.spdCurve.points[1].x,
				routeSegLrg.spdCurve.points[1].y,
				routeSegLrg.spdCurve.points[2].x,
				routeSegLrg.spdCurve.points[2].y,
				routeSegLrg.fb
			));
		});
		
		return module.getRouteSml(
			routeLrg.routeId,
			routeLrg.destinationType,
			routeLrg.destinationId,
			routeLrg.plrShipId,
			routeSegsSml
		);
	};
	
	/**
	 * Returns the current x,y position based on a large route segment data structure.
	 *
	 * @return {x : 0, y : 0} or null if this route is not active.
	 */
	module.getPosOnRoute = function(routeLrg, timeMs) {
		var curRouteSeg = null;
		for(let i = 0; i < routeLrg.routeSegs.length; i++) {
			if((1000 * routeLrg.routeSegs[i].sCrd.t) <= timeMs && (1000 * routeLrg.routeSegs[i].eCrd.t) >= timeMs) {
				curRouteSeg = routeLrg.routeSegs[i];
				break;
			}
		};
		
		if(null == curRouteSeg)
			return null;
		
		var pctComplete = (timeMs - (1000 * curRouteSeg.sCrd.t)) / ((1000 * curRouteSeg.eCrd.t) - (1000 * curRouteSeg.sCrd.t));
		
		var spdPos = curRouteSeg.spdCurve.get(pctComplete);
		return curRouteSeg.posCurve.get(spdPos.y);
	};
	
	/**
	 * Function to determine the player's location type and location id at a
	 * given time. Does not update any data, just parses the player's record
	 * and route information and determines where the player currently is.
	 *
	 * Calls callback function with parameters locationType and locationId.
	 */
	module.getLocationAtTime = function(locationType, locationId, timeMs, routeSmlArr) {
		var retLocation = {locationType : module.LOCATION_TYPE_UNKNOWN, locationId : 0};
		
		if(module.LOCATION_TYPE_STATION == locationType) {
			// If we're on a station, we just return that
			retLocation.locationType = module.LOCATION_TYPE_STATION;
			retLocation.locationId = locationId;
		} else if(module.LOCATION_TYPE_ROUTE == locationType) {
			// We're on a route, need to check its state and return accordingly
			var route = routeSmlArr.find(function(r) { return r.id == locationId; });
			
			if(route.rd[route.rd.length - 1].eCrd.t <= timeMs / 1000) {
				// The route is over, we are at the destination
				if(module.DESTINATION_TYPE_STATION == route.dt) {
					retLocation.locationType = module.LOCATION_TYPE_STATION;
					retLocation.locationId = route.di;
				} else {
					console.log("Non-station destination found, currently only stations supported.");
				}
			} else {
				// We are on this route, either in docking or on the route itself
				// TODO handle routes starting in the future and show the player as "DOCKING"
				retLocation.locationType = module.LOCATION_TYPE_ROUTE;
				retLocation.locationId = locationId;
			}
		} else {
			console.log("Unknown player location type: " + playerRecord['location_type']);
		}
		
		return retLocation;
	};
	
	/**
	 * Attempts to generate a route segment from two coordinates. This is a
	 * "dumb" function, it just attempts to generate a valid segment and returns
	 * null if it can't. This function assumes it is passed valid starting and
	 * ending coordinates.
	 *
	 * TODO redefine this so that it always returns a curve. We'd like this function to just give a curve from point A to point B.
	 * This function's primary goal is to map the curve based on the crds, which includes the direction the curve travels, and the
	 * speed along that path. The onus will be on the user of this function to make sure the crds are "sane". If you pass garbage,
	 * you'll get garbage.
	 *
	 * @return A routeSegSml data structure or null if it couldn't generate one
	 */
	module.getCurveFromCrds = function(sCrd, eCrd) {
		// First check if the opposing point is on the same side that the vector is pointing
		var diffVec = new Victor(eCrd.pos.x, eCrd.pos.y);
		diffVec.subtract(new Victor(sCrd.pos.x, sCrd.pos.y));
		
		// The Victor library's horizontalAngleDeg returns a number between -180
		// and 180, with a vector of 1,0 returning 0. We need to translate this
		// to a normal 0-360 number for comparison, hence the 360 constants
		var diffVecAngle = (360 + diffVec.horizontalAngleDeg()) % 360;
		
		var sVecAngleDiff = ((360 + (new Victor(sCrd.mov.x, sCrd.mov.y)).horizontalAngleDeg()) % 360) - diffVecAngle;
		var eVecAngleDiff = ((360 + (new Victor(eCrd.mov.x, eCrd.mov.y)).horizontalAngleDeg()) % 360) - diffVecAngle;
		
		// We want to ensure this is a simple curve, meaning that the entrance and exit vectors are in line with the
		// direction of travel, and that they form an arc between them.
		// TODO make the upper limit less than 90 to prevent control points that are super far away
		// TODO remove this conditional
		/*
		var maxAngleDiff = 90;
		if(!((sVecAngleDiff < maxAngleDiff && sVecAngleDiff > 0) && (eVecAngleDiff > (-1 * maxAngleDiff) && eVecAngleDiff < 0)) &&
		   !((sVecAngleDiff > (-1 * maxAngleDiff) && sVecAngleDiff < maxAngleDiff) && (eVecAngleDiff < maxAngleDiff && eVecAngleDiff > 0))) {
			return null;
		}
		*/
		
		var x1 = sCrd.pos.x;
		var y1 = sCrd.pos.y;
		var x2 = sCrd.pos.x + sCrd.mov.x;
		var y2 = sCrd.pos.y + sCrd.mov.y;
		var x3 = eCrd.pos.x;
		var y3 = eCrd.pos.y;
		var x4 = eCrd.pos.x + eCrd.mov.x;
		var y4 = eCrd.pos.y + eCrd.mov.y;
		
		var px, py;
		var denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);
		
		if(Math.abs(denom) < 0.01) { // 0 means parallel, so we just set the control point to halfway
			var mag = diffVec.length();
			
			diffVec.normalize().multiply(new Victor(mag / 2, mag / 2));
			diffVec.add(new Victor(sCrd.pos.x, sCrd.pos.y));
			
			px = diffVec.x;
			py = diffVec.y;
		} else {
			px = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;
			py = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;
		}
		
		// We set each control point to be the same distance from it's parent point to smooth out the curve
		var cp1 = new Victor(px, py);
		var cp2 = new Victor(px, py);
		cp1.subtract(new Victor(sCrd.pos.x, sCrd.pos.y));
		cp2.subtract(new Victor(eCrd.pos.x, eCrd.pos.y));
		cp1Mag = cp1.length();
		cp2Mag = cp2.length();
		
		if(cp1Mag > cp2Mag) {
			cp1.normalize().multiply(new Victor(cp2Mag, cp2Mag));
		} else {
			cp2.normalize().multiply(new Victor(cp1Mag, cp1Mag));
		}
		
		cp1.add(new Victor(sCrd.pos.x, sCrd.pos.y));
		cp2.add(new Victor(eCrd.pos.x, eCrd.pos.y));
		
		// We now have our position curve defined, time to generate the curve that defines our speed
		return module.getRouteSegSml(
			sCrd, eCrd, cp1.x, cp1.y, cp2.x, cp2.y,
			0,0.5,1,0.5,0 // TODO add speed control point determination as well as fuel burn levels
		);
	};
	
	/**
	 * Function to validate an array of route segments. Does not check if start
	 * or end locations are valid, just the route itself.
	 *
	 * @return boolean
	 */
	module.validateRoute = function(maxMobility, routeSegsLrg, celestialBodies) {
		return true; // We are temporarily accepting all routes
		
		if(0 >= routeSegsLrg.length || module.MAX_ROUTE_SEGMENTS < routeSegsLrg.length)
			return false;
		if(module.MAX_ROUTE_TIME_SEC < routeSegsLrg[routeSegsLrg.length - 1].eCrd.t - routeSegsLrg[0].sCrd.t)
			return false;
		
		//var x1,y1,x2,y2,x3,y3,x4,y4;
		
		for(let i = 0; i < routeSegsLrg.length; i++) {
			if(routeSegsLrg[i].sCrd.t     != Math.round(routeSegsLrg[i].sCrd.t))
				return false;
			if(routeSegsLrg[i].sCrd.pos.x != Math.round(routeSegsLrg[i].sCrd.pos.x))
				return false;
			if(routeSegsLrg[i].sCrd.pos.y != Math.round(routeSegsLrg[i].sCrd.pos.y))
				return false;
			if(routeSegsLrg[i].eCrd.t     != Math.round(routeSegsLrg[i].eCrd.t))
				return false;
			if(routeSegsLrg[i].eCrd.pos.x != Math.round(routeSegsLrg[i].eCrd.pos.x))
				return false;
			if(routeSegsLrg[i].eCrd.pos.y != Math.round(routeSegsLrg[i].eCrd.pos.y))
				return false;
			
			// Ensure the start crd is equal to the end crd of the previous segment.
			// Because we verify that the bezier curve lines up with the start
			// and end coordinates, we don't need to compare the vectors of two
			// separate segments, just the start and end coordinates.
			if(1 <= i) {
				if(routeSegsLrg[i].sCrd.t     != routeSegsLrg[i - 1].eCrd.t)
					return false;
				if(routeSegsLrg[i].sCrd.pos.x != routeSegsLrg[i - 1].eCrd.pos.x)
					return false;
				if(routeSegsLrg[i].sCrd.pos.y != routeSegsLrg[i - 1].eCrd.pos.y)
					return false;
			}
			
			if(routeSegsLrg[i].sCrd.t >= routeSegsLrg[i].eCrd.t)
				return false;
			
			// Ensure our coordinates positions are equal to our curves
			if(routeSegsLrg[i].sCrd.pos.x != routeSegsLrg[i].posCurve.points[0].x)
				return false;
			if(routeSegsLrg[i].sCrd.pos.y != routeSegsLrg[i].posCurve.points[0].y)
				return false;
			if(routeSegsLrg[i].eCrd.pos.x != routeSegsLrg[i].posCurve.points[3].x)
				return false;
			if(routeSegsLrg[i].eCrd.pos.y != routeSegsLrg[i].posCurve.points[3].y)
				return false;
			
			/*
			verify that the bezier curve is a "simple" curve as defined in the getCurveFromCrds function above
			verify that the bezier curve is travelling in the same direction as the start and end coordinate movement vectors
			verify that the speed the ship is travelling at the start and end is equal to the movement vector of the corresponding crds
			*/
		}
		
		// Now that we have verified the basics of the segments, we verify that the ship can power itself along the proposed path
		for(let i = 0; i < routeSegsLrg.length; i++) {
			// TODO
			// get the drift crd
			// compare it to the position along the path
			// see if the ship's power is greater than the vector difference between the points
			// verify we don't collide with any celestial bodies
		}
		
		return true;
	};
	
	/**
	 * Function to calculate the altitude at which the pull from two celestial
	 * bodies is approximately equal. Returned integer altitude is based on the
	 * primary body.
	 */
	module.getTippingAltitude = function(primaryBody, secondaryBody) { return 0; };
	
	// Used for ascent / descent around a single body
	module.plotSingleBodyRoute = function(sCrd, eCrd, celestialBodies) {};
	
	module.plotInterBodyRoute = function(sCrd, eCrd, celestialBodies) {};
	
	/**
	 * The big kahuna. Plots a route between two coordinates if possible,
	 * returns null if it can't.
	 *
	 * @return Array of route segments, or null if a route could not be plotted.
	 */
	module.plotRoute = function(maxMobility, sCrd, eCrd, celestialBodies) {
		if(0 == maxMobility) {
			// We ignore the eCrd param if we are just drifting
			return module.plotDrift(sCrd, sCrd.t + module.MAX_ROUTE_TIME_SEC, celestialBodies);
		}
		
		// TODO Actual implementation of orbital plotting
		var curve = module.getCurveFromCrds(sCrd, eCrd);
		
		return [curve];
	};
	
	module.plotDrift = function(sCrd, endTimeSc, celestialBodies) {
		var retSegsLrg = [];
		var curStartCrd = sCrd;
		var oldDriftCrd = sCrd;
		var newDriftCrd;
		var curStartCrdAngle = (360 + (new Victor(curStartCrd.pos.x + curStartCrd.mov.x, curStartCrd.pos.y + curStartCrd.mov.y)).horizontalAngleDeg()) % 360;
		var newDriftCrdAngle;
		
		while(curStartCrd.t < endTimeSc) {
			OrbitalMechanics().populateOrbitalPositions(celestialBodies, oldDriftCrd.t * 1000);
			
			newDriftCrd = OrbitalMechanics().getDriftCoordinate(
				oldDriftCrd.pos,
				oldDriftCrd.mov,
				oldDriftCrd.t,
				OrbitalMechanics().TIME_UNIT,
				celestialBodies,
				false
			);
			
			newDriftCrdAngle = (360 + (new Victor(newDriftCrd.pos.x + newDriftCrd.mov.x, newDriftCrd.pos.y + newDriftCrd.mov.y)).horizontalAngleDeg()) % 360;
			
			if(newDriftCrd.t > endTimeSc ||
				(module.MAX_ROUTE_SEG_TURN_DEG < Math.abs(curStartCrdAngle - newDriftCrdAngle) &&
				module.MAX_ROUTE_SEG_TURN_DEG < 360 - Math.abs(curStartCrdAngle - newDriftCrdAngle))
			) {
				retSegsLrg.push(module.getCurveFromCrds(curStartCrd, oldDriftCrd));
				
				curStartCrd = oldDriftCrd;
				
				curStartCrdAngle = (360 + (new Victor(curStartCrd.pos.x + curStartCrd.mov.x, curStartCrd.pos.y + curStartCrd.mov.y)).horizontalAngleDeg()) % 360;
			} else {
				oldDriftCrd = newDriftCrd;
			}
		}
		
		return retSegsLrg;
	};
	
	return module;
};




















},{"./OrbitalMechanics":15,"bezier-js":18,"victor":22}],15:[function(require,module,exports){
var Victor = require('victor');

module.exports = function() {
	var module = {};
	
	module.SOL_ID                 = 1; // Special case for the ID of the sun in the db TODO remove moved to MapData
	module.EARTH_SECONDS_IN_YEAR  = 31540000;
	module.SECONDS_IN_HOUR        = 3600;
	module.CENTER_OF_SYSTEM       = 0; // Previously was 2^32 / 2, but we're using signed integers for position now
	module.GRAVITATIONAL_CONSTANT = 0.001; // Calculated based on Earth at 150m km and Sun mass of 330m over period of 1/60th a revolution
	//module.GRAVITATIONAL_CONSTANT = 10; // Calculated based on Earth at 150m km and Sun mass of 330m over period of 1/60th a revolution
	module.EARTH_YEAR_PERIOD      = 60; // In game seconds that the Earth takes to orbit the sun
	module.PI_OVER_180            = 0.01745329251;
	module.TIME_UNIT              = module.EARTH_YEAR_PERIOD / 60; // The unit of time used for speed calculations, route checks, etc
	
	/**
	 * TODO remove moved to MapData
	 * Data structure for a location in space and time.
	 */
	module.getCrd = function(posX, posY, movX, movY, timestamp) {
		var crd = {};
		
		crd.pos = {x : posX, y : posY};
		crd.mov = {x : movX, y : movY};
		crd.t = timestamp;
		
		return crd;
	};
	
	module.crdsAreEqual = function(crdA, crdB, errorThreshold) {
		if(Math.abs(crdA.pos.x - crdB.pos.x) > errorThreshold)
			return false;
		if(Math.abs(crdA.pos.y - crdB.pos.y) > errorThreshold)
			return false;
		if(Math.abs(crdA.mov.x - crdB.mov.x) > errorThreshold)
			return false;
		if(Math.abs(crdA.mov.y - crdB.mov.y) > errorThreshold)
			return false;
		if(Math.abs(crdA.t - crdB.t) > errorThreshold)
			return false;
			
		return true;
	};
	
	/**
	 * Calculate the position of a given body assuming circular orbit.
	 * Returns an array with two values, the first being X and the second being Y.
	 */
	module.getOrbitalPosition = function(parentPosition, distanceFromParent, orbitalPeriodHours, targetTimeMs, thetaOffsetDeg) {
		var orbitalPeriodSeconds = (orbitalPeriodHours * module.SECONDS_IN_HOUR) * (module.EARTH_YEAR_PERIOD / module.EARTH_SECONDS_IN_YEAR);
		var percentYearCompleted = ((targetTimeMs / 1000) % orbitalPeriodSeconds) / orbitalPeriodSeconds;
		var theta = ((360 * percentYearCompleted) + thetaOffsetDeg ) % 360;

		// TODO do we want to round the return here?
		return {x : Math.round(parentPosition.x + (Math.cos(theta * module.PI_OVER_180) * distanceFromParent)),
		        y : Math.round(parentPosition.y + (Math.sin(theta * module.PI_OVER_180) * distanceFromParent))};
	};
	
	/**
	 * Takes an array of celestial bodies and populates each with a position.
	 */
	module.populateOrbitalPositions = function(celestialBodies, targetTimeMs) {
		// Clear their old positions first
		for(var i = 0; i < celestialBodies.length; i++) {
			celestialBodies[i]['pos'] = null;
		}

		for(var i = 0; i < celestialBodies.length; i++) {
			module.populateOrbitalPosition(celestialBodies, i, targetTimeMs);
		}
	};
	
	module.populateOrbitalPosition = function(celestialBodies, i, targetTimeMs) {
		if(null != celestialBodies[i]['pos']) {
			return; // We have already calculated this position
		}
		
		if(module.SOL_ID == celestialBodies[i]['celestial_body_id']) {
			celestialBodies[i]['pos'] = {x : module.CENTER_OF_SYSTEM, y : module.CENTER_OF_SYSTEM};
		} else {
			// Look for the parent
			var found = false;
			
			for(var j = 0; j < celestialBodies.length; j++) {
				if(celestialBodies[i]['parent_body_id'] == celestialBodies[j]['celestial_body_id']) {
					// Found the parent

					if(null == celestialBodies[j]['pos']) {
						// Parent hasn't been calculated yet, calculate it
						module.populateOrbitalPosition(celestialBodies, j, targetTimeMs);
					}
					
					celestialBodies[i]['pos'] = module.getOrbitalPosition(celestialBodies[j]['pos'],
					                                                      celestialBodies[i]['distance_from_parent'],
											                              celestialBodies[i]['orbital_period_hours'],
											                              targetTimeMs, 0);

					found = true;
					break;
				}
			}
			
			if(!found) {
				// TODO this should be an exception
				console.log('Could not find parent ' + celestialBodies[i]['parent_body_id'] + ' for body ' + celestialBodies[i]['celestial_body_id']);
				celestialBodies[i]['pos'] = {x : 0, y : 0};
			}
		}
	}
	
	/**
	 * Returns a new coordinate for the player after timeframe seconds given no engine power
	 * @param position Vector array [0,0].
	 * @param movement Vector array.
	 * @param celestialBodies Array of objects, each object containing ["mass"=0, "pos"=[0,0]]
	 * TODO change from seconds to ms
	 * TODO change params to just take a coordinate
	 * TODO remove timeframe param, movement vector is inherently based on time, all of this needs to be handled internally to OrbitalMechanics
	 */
	module.getDriftCoordinate = function(position, movement, timestamp, timeframe, celestialBodies, round = false) {
		var distanceSq = 0;
		var gravitationalVector = new Victor(0, 0);
		var movementVector = new Victor(movement.x, movement.y);
		var positionVector = new Victor(position.x, position.y)
		var pullMag = 0;
		
		for(var i = 0; i < celestialBodies.length; i++) {
			// get distance from celestial body by subtracting positionVector from the celestialBody x and y values
			gravitationalVector.copyX(celestialBodies[i]["pos"]); // Set start of gravitational position to parent
			gravitationalVector.copyY(celestialBodies[i]["pos"]); // Set start of gravitational position to parent
			gravitationalVector.subtract(positionVector); // Subtract the child to get a distance vector from child to parent
			distance = gravitationalVector.length();
			
			pullMag = module.getGravitationalPull(celestialBodies[i]['mass'], distance, timeframe);
			
			gravitationalVector.normalize();
			gravitationalVector.multiply(new Victor(pullMag, pullMag));
			gravitationalVector.multiply(new Victor(timeframe, timeframe));
			
			movementVector.add(gravitationalVector); // Adjust the movement vector according to the pull of this body
		}
		
		positionVector.add(movementVector);
		
		if(round) {
			positionVector.x = Math.round(positionVector.x);
			positionVector.y = Math.round(positionVector.y);
			movementVector.x = Math.round(movementVector.x);
			movementVector.y = Math.round(movementVector.y);
		}
		
		return module.getCrd(positionVector.x, positionVector.y, movementVector.x, movementVector.y, timestamp + timeframe);
	};

	/**
	 * Function that determines the length of the vector applied to a body given parameters.
	 * Returns meters per second as an int
	 */
	module.getGravitationalPull = function(mass, distance, timeFrameSec) {
		// Because our gravitational constant is based on 1/60 of an Earth year, we need to adjust it based on our timeframe
		return (timeFrameSec / module.TIME_UNIT) * (module.GRAVITATIONAL_CONSTANT * (mass / (distance * distance)));
	};
	
	module.getDistanceSq = function(aX, aY, bX, bY) {
		var a = aX - bX;
		var b = aY - bY;
		
		return (a * a) + (b * b);
	};
	
	/**
	 * Removed because we're storing the orbital period in the DB
	 * Returns integer time in seconds.
	 */
	module.getOrbitalPeriod = function(distanceFromParent, parentMass) {
		return 2 * Math.PI * Math.sqrt(
			(distanceFromParent * distanceFromParent * distanceFromParent) /
			(module.GRAVITATIONAL_CONSTANT * parentMass)
		);
	};
	
	/**
	 * Function to add a 'orbital_period_hours' field to each celestial body.
	 *
	 * @return celestialBodies with populated 'orbital_period_hours' field for each.
	 */
	module.populateOrbitalPeriods = function(celestialBodies) {
		for(var i = 0; i < celestialBodies.length; i++) {
			if(module.SOL_ID == celestialBodies[i]['celestial_body_id']) {
				celestialBodies[i]['orbital_period_hours'] = 0;
			}
			
			if(undefined == celestialBodies[i]['orbital_period_hours']) {
				for(var j = 0; j < celestialBodies.length; j++) {
					if(celestialBodies[i]['parent_body_id'] == celestialBodies[j]['celestial_body_id']) {
						celestialBodies[i]['orbital_period_hours'] = module.getOrbitalPeriod(
							celestialBodies[i]['distance_from_parent'],
							celestialBodies[j]['mass']
						);
					}
				}
			}
		}
		
		return celestialBodies;
	};
	
	/**
	 * Similar to getOrbitalPeriod, but returns the speed at which a body is
	 * travelling relative to it's parent for a given distance.
	 * TODO this is untested
	 *
	 * @return Integer
	 */
	module.getOrbitalSpeed = function(distanceFromParent, parentMass, earthYearPeriodSeconds) {
		var orbitalPeriod = module.getOrbitalPeriod(distanceFromParent, parentMass);
		
		return ((2 * Math.PI * distanceFromParent) / module.TIME_UNIT) / orbitalPeriod;
	};
	
	module.getStationCrd = function(stationDef, timeMs, celestialBodies, updateBodyPositions = true) {
		if(updateBodyPositions) {
			module.populateOrbitalPositions(celestialBodies, timeMs);
		}
		
		var pos = {x : 0, y : 0};
		
		for(let i = 0; i < celestialBodies.length; i++) {
			if(celestialBodies[i]['celestial_body_id'] == stationDef['parent_body_id']) {
				pos = module.getOrbitalPosition(
					celestialBodies[i]['pos'],
					stationDef['distance_from_parent'],
					stationDef['orbital_period_hours'],
					timeMs,
					0
				);
			}
		}
		
		return module.getCrd(pos.x, pos.y, 0, 0, Math.round(timeMs / 1000));
	};
	
	module.getEscapeVelocity = function(parentMass, distanceFromParent) {
		return Math.sqrt((2 * module.GRAVITATIONAL_CONSTANT * parentMass) / distanceFromParent);
	};
	
	return module;
};

},{"victor":22}],16:[function(require,module,exports){
const DataValidator = require('./DataValidator');
const OrbitalMechanics = require('./OrbitalMechanics');
const Bezier = require('bezier-js');

module.exports = {
	PATH_NONE:  0,
	PATH_POINT: 1,
	PATH_ORBIT: 2,
	PATH_CURVE: 3,
	
	templates: function() {
		var obj = {};
		
		obj.point = {
			x: {type: DataValidator.DATA_FLOAT},
			y: {type: DataValidator.DATA_FLOAT}
		};
		
		obj.crd = {
			pos: {type: DataValidator.DATA_OBJ, template: obj.point},
			mov: {type: DataValidator.DATA_OBJ, template: obj.point},
			tMs: {type: DataValidator.DATA_INT}
		};
		
		obj.pathSeg = {
			sCrd: {type: DataValidator.DATA_OBJ, template: obj.crd},
			eCrd: {type: DataValidator.DATA_OBJ, template: obj.crd},
			pathCtrl1: {type: DataValidator.DATA_OBJ, template: obj.point},
			pathCtrl2: {type: DataValidator.DATA_OBJ, template: obj.point},
			fuelBurn: {type: DataValidator.DATA_FLOAT}
		};
		
		return obj;
	},
	
	PathObj: function() {
		this.type = module.exports.PATH_NONE;
		this.pos = {x: 0, y: 0};
		this.data = {};
		
		this.updatePos = function(timeMs) {};
		
		this.toJson = function() {
			// TODO make it so we're able to check data with a template based on type
			// This will be used in the getPath switch as well
			return JSON.stringify(DataValidator.cleanObj(this, {
				type: {type: DataValidator.DATA_INT},
				data: {type: DataValidator.DATA_ANY}
			}));
		};
	},
	
	getPathFromJson: function(pathJson) {
		var tempPath = JSON.parse(pathJson);
		return module.exports.getPath(tempPath.type, tempPath.data);
	},
	
	getPath: function(pathType, pathData) {
		var pathObj = new module.exports.PathObj();
		
		switch(DataValidator.cleanData(pathType, DataValidator.DATA_INT)) {
			case module.exports.PATH_NONE:
				pathObj.type = module.exports.PATH_NONE;
				pathObj.updatePos = module.exports.updatePosNone;
			break;
			
			case module.exports.PATH_POINT:
				pathObj.type = module.exports.PATH_POINT;
				pathObj.updatePos = module.exports.updatePosPoint;
			break;
			
			case module.exports.PATH_ORBIT:
				pathObj.type = module.exports.PATH_ORBIT;
				pathObj.updatePos = module.exports.updatePosOrbit;
				
				pathObj.data = DataValidator.cleanObj(pathData, {
					distanceFromParent: {type: DataValidator.DATA_INT},
					orbitalPeriodHours: {type: DataValidator.DATA_INT},
					thetaOffsetDeg: {type: DataValidator.DATA_FLOAT},
					parentId: {type: DataValidator.DATA_INT}
				});
				
				// By default we orbit around the origin, but this is typically set to
				// anoter path's pos in the MapData map construction
				pathObj.data.parentPos = {x: 0, y: 0};
			break;
			
			case module.exports.PATH_CURVE:
				pathObj.type = module.exports.PATH_CURVE;
				pathObj.updatePos = module.exports.updatePosCurve;
				
				pathObj.data = DataValidator.cleanObj(pathData, {
					pathSegs: {
						type: DataValidator.DATA_ARR,
						arrType: DataValidator.DATA_OBJ,
						template: module.exports.templates().pathSeg
					},
					
//					destType: {},
//					destData: {type: DataValidator.DATA_OBJ, template: {
//						// TODO
//					}},
				});
				
				for(let i = 0; i < pathObj.data.pathSegs.length; i++) {
					pathObj.data.pathSegs[i].posCurve = new Bezier(
						pathObj.data.pathSegs[i].sCrd.pos.x,
						pathObj.data.pathSegs[i].sCrd.pos.y,
						pathObj.data.pathSegs[i].pathCtrl1.x,
						pathObj.data.pathSegs[i].pathCtrl1.y,
						pathObj.data.pathSegs[i].pathCtrl2.x,
						pathObj.data.pathSegs[i].pathCtrl2.y,
						pathObj.data.pathSegs[i].eCrd.pos.x,
						pathObj.data.pathSegs[i].eCrd.pos.y
					);
				}
			break;
			
			default:
				throw "Unrecognized path type: "+ pathType;
			break;
		}
		
		return pathObj;
	},
	
	updatePosNone: function(timeMs) {},
	updatePosPoint: function(timeMs) {},
	
	updatePosOrbit: function(timeMs) {
		// TODO modify how we're getting the orbital position so that we can just update this.pos directly
		// We don't override this.pos because it is potentially referenced by other Path objects
		var tempPos = OrbitalMechanics().getOrbitalPosition(
			this.data.parentPos,
			this.data.distanceFromParent,
			this.data.orbitalPeriodHours,
			timeMs,
			this.data.thetaOffsetDeg
		);
		
		this.pos.x = tempPos.x;
		this.pos.y = tempPos.y;
	},
	
	updatePosCurve: function(timeMs) {
		for(let i = 0; i < this.data.pathSegs.length; i++) {
			if(this.data.pathSegs[i].sCrd.tMs <= timeMs && this.data.pathSegs[i].eCrd.tMs >= timeMs) {
				var tempPos = this.data.pathSegs[i].posCurve.get(
					(timeMs - this.data.pathSegs[i].sCrd.tMs) / (this.data.pathSegs[i].eCrd.tMs - this.data.pathSegs[i].sCrd.tMs)
				);
				
				this.pos.x = tempPos.x;
				this.pos.y = tempPos.y;
				
				return;
			}
		}
		
		// If we get here it means we did not find an active segment
		// TODO emit an event to let the map know?
		this.updatePos = module.exports.updatePosNone;
	},
};

},{"./DataValidator":12,"./OrbitalMechanics":15,"bezier-js":18}],17:[function(require,module,exports){
module.exports = function() {
	var module = {};
	
	module.CMPLT_PCT_WINDOW_SC   = 86400;
	module.QUEST_VALUE_WINDOW_SC = 86400;
	module.RECYCLE_WINDOW_SC     = 86400; // plr_quests records are recycled after this time
	
	/**
	 * Data structure for a generated quest instance.
	 *
	 * @param defQuestId The definition quest this instance was based off of
	 * @param maxTimeSc The total time that the player has to complete this quest, not the real time but the delta
	 */
	module.getQuestInstance = function(defQuestId, destinationStationId, defCommodityId, commodityQuantity, questValue, maxTimeSc, rewardItemType, rewardItemId, rewardItemQuantity) {
		var quest = {};
		
		quest.defQuestId           = defQuestId;
		quest.destinationStationId = destinationStationId;
		quest.defCommodityId       = defCommodityId;
		quest.commodityQuantity    = commodityQuantity;
		quest.questValue           = questValue;
		quest.maxTimeSc            = maxTimeSc;
		quest.rewardItemType       = rewardItemType;
		quest.rewardItemId         = rewardItemId;
		quest.rewardItemQuantity   = rewardItemQuantity;
		
		return quest;
	};
	
	/**
	 * Function to take a quest definition and generate a questInstance data structure.
	 */
	module.generateQuestInstance = function(defQuest, defCommodities) {
		var commodities = defCommodities.filter(e => e['commodity_type'] == defQuest['cargo_commodity_type']);
		var commodity = commodities[Math.floor(Math.random() * commodities.length)];
		
		var cargoQuantity = Math.floor(Math.random() * (defQuest['cargo_quantity_max'] - defQuest['cargo_quantity_min'])) + defQuest['cargo_quantity_min'];
		
		var destStations = defQuest['destination_station_ids'].split(',');
		var destStationId = destStations[Math.floor(Math.random() * destStations.length)];
		
		var rewardItemQuantity = defQuest['reward_item_quantity_min'] + Math.floor(Math.random() * (defQuest['reward_item_quantity_max'] - defQuest['reward_item_quantity_min']));
		
		return module.getQuestInstance(
			defQuest['quest_id'],
			destStationId,
			commodity['commodity_id'],
			cargoQuantity,
			defQuest['quest_value'],
			defQuest['max_time_sc'],
			defQuest['reward_item_type'],
			defQuest['reward_item_id'],
			rewardItemQuantity
		);
	};
	
	module.validateQuestInstance = function(defQuest, defCommodities, questInstance) {
		if(questInstance.commodityQuantity > defQuest['cargo_quantity_max'])
			return false;
		if(questInstance.commodityQuantity < defQuest['cargo_quantity_min'])
			return false;
		if(questInstance.rewardItemType != defQuest['reward_item_type'])
			return false;
		if(questInstance.rewardItemId != defQuest['reward_item_id'])
			return false;
		if(questInstance.rewardItemQuantity < defQuest['reward_item_quantity_min'])
			return false;
		if(questInstance.rewardItemQuantity > defQuest['reward_item_quantity_max'])
			return false;
		if(questInstance.maxTimeSc != defQuest['max_time_sc'])
			return false;
		
		var commodities = defCommodities.filter(e => e['commodity_type'] == defQuest['cargo_commodity_type']);
		if(undefined == commodities.find(e => e['commodity_id'] == questInstance.defCommodityId))
			return false;
		
		var destStations = defQuest['destination_station_ids'].split(',');
		if(undefined == destStations.find(e => e == questInstance.destinationStationId))
			return false;
		
		return true;
	};
	
	// For the completion rate of all of a player's completed quests
	module.getPlrCmpltPct = function(currTimeMs, plrQuests) {
		var c   = 0;
		var sum = 0;
		var cutoffTimeSc = Math.round((currTimeMs / 1000) - module.CMPLT_PCT_WINDOW_SC);
		
		plrQuests.forEach(function(plrQuest) {
			if(plrQuest['completed_time_sc'] > cutoffTimeSc) {
				c++;
				sum += plrQuest['completed_pct_1000'];
			}
		});
		
		if(0 == c)
			return 1;
		
		sum /= 1000;
		
		return sum / c;
	};
	
	/**
	 * Gets the sum of the quest value of all player quests within the
	 * QUEST_VALUE_WINDOW_SC window. This does not count any active quests.
	 */
	module.getPlrQuestValueSum = function(currTimeMs, plrQuests) {
		var sum = 0;
		var cutoffTimeSc = Math.round((currTimeMs / 1000) - module.QUEST_VALUE_WINDOW_SC);
		
		plrQuests.forEach(function(plrQuest) {
			if(plrQuest['completed_time_sc'] > cutoffTimeSc)
				sum += plrQuest['quest_value'];
		});
		
		return sum;
	};
	
	return module;
};

},{}],18:[function(require,module,exports){
module.exports = require('./lib/bezier');

},{"./lib/bezier":19}],19:[function(require,module,exports){
/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      min = Math.min,
      max = Math.max,
      acos = Math.acos,
      sqrt = Math.sqrt,
      pi = Math.PI,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};

  // quite needed
  var utils = require('./utils.js');

  // not quite needed, but eventually this'll be useful...
  var PolyBezier = require('./poly-bezier.js');

  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2] };
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) dims.push('z');
    this.dims = dims;
    this.dimlen = dims.length;

    (function(curve) {
      var order = curve.order;
      var points = curve.points;
      var a = utils.align(points, {p1:points[0], p2:points[order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));

    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  Bezier.fromSVG = function(svgString) {
    var list = svgString.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g).map(parseFloat);
    var relative = /[cq]/.test(svgString);
    if(!relative) return new Bezier(list);
    list = list.map(function(v,i) {
      return i < 2 ? v : v + list[i % 2];
    });
    return new Bezier(list);
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = utils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = utils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = utils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = utils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };

  var getUtils = function() {
    return utils;
  };

  Bezier.getUtils = getUtils;

  Bezier.prototype = {
    getUtils: getUtils,
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return utils.pointsToString(this.points);
    },
    toSVG: function(relative) {
      if(this._3d) return false;
      var p = this.points,
          x = p[0].x,
          y = p[0].y,
          s = ["M", x, y, (this.order===2 ? "Q":"C")];
      for(var i=1, last=p.length; i<last; i++) {
        s.push(p[i].x);
        s.push(p[i].y);
      }
      return s.join(" ");
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      };
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return utils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (utils.dist(c,point) < error) {
          hits.push(c)
          t += i / lut.length;
        }
      }
      if(!hits.length) return false;
      return t /= hits.length;
    },
    project: function(point) {
      // step 1: coarse check
      var LUT = this.getLUT(), l = LUT.length-1,
          closest = utils.closest(LUT, point),
          mdist = closest.mdist,
          mpos = closest.mpos;
      if (mpos===0 || mpos===l) {
        var t = mpos/l, pt = this.compute(t);
        pt.t = t;
        pt.d = mdist;
        return pt;
      }

      // step 2: fine check
      var ft, t, p, d,
          t1 = (mpos-1)/l,
          t2 = (mpos+1)/l,
          step = 0.1/l;
      mdist += 1;
      for(t=t1,ft=t; t<t2+step; t+=step) {
        p = this.compute(t);
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          ft = t;
        }
      }
      p = this.compute(ft);
      p.t = ft;
      p.d = mdist;
      return p;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        var ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    raise: function() {
      var p = this.points, np = [p[0]], i, k=p.length, pi, pim;
      for (var i=1; i<k; i++) {
        pi = p[i];
        pim = p[i-1];
        np[i] = {
          x: (k-i)/k * pi.x + i/k * pim.x,
          y: (k-i)/k * pi.y + i/k * pim.y
        };
      }
      np[k] = p[k-1];
      return new Bezier(np);
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    },
    inflections: function() {
      return utils.inflections(this.points);
    },
    normal: function(t) {
      return this._3d ? this.__normal3(t) : this.__normal2(t);
    },
    __normal2: function(t) {
      var d = this.derivative(t);
      var q = sqrt(d.x*d.x + d.y*d.y)
      return { x: -d.y/q, y: d.x/q };
    },
    __normal3: function(t) {
      // see http://stackoverflow.com/questions/25453159
      var r1 = this.derivative(t),
          r2 = this.derivative(t+0.01),
          q1 = sqrt(r1.x*r1.x + r1.y*r1.y + r1.z*r1.z),
          q2 = sqrt(r2.x*r2.x + r2.y*r2.y + r2.z*r2.z);
      r1.x /= q1; r1.y /= q1; r1.z /= q1;
      r2.x /= q2; r2.y /= q2; r2.z /= q2;
      // cross product
      var c = {
        x: r2.y*r1.z - r2.z*r1.y,
        y: r2.z*r1.x - r2.x*r1.z,
        z: r2.x*r1.y - r2.y*r1.x
      };
      var m = sqrt(c.x*c.x + c.y*c.y + c.z*c.z);
      c.x /= m; c.y /= m; c.z /= m;
      // rotation matrix
      var R = [   c.x*c.x,   c.x*c.y-c.z, c.x*c.z+c.y,
                c.x*c.y+c.z,   c.y*c.y,   c.y*c.z-c.x,
                c.x*c.z-c.y, c.y*c.z+c.x,   c.z*c.z    ];
      // normal vector:
      var n = {
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n;
    },
    hull: function(t) {
      var p = this.points,
          _p = [],
          pt,
          q = [],
          idx = 0,
          i=0,
          l=0;
      q[idx++] = p[0];
      q[idx++] = p[1];
      q[idx++] = p[2];
      if(this.order === 3) { q[idx++] = p[3]; }
      // we lerp between all points at each iteration, until we have 1 point left.
      while(p.length>1) {
        _p = [];
        for(i=0, l=p.length-1; i<l; i++) {
          pt = utils.lerp(t,p[i],p[i+1]);
          q[idx++] = pt;
          _p.push(pt);
        }
        p = _p;
      }
      return q;
    },
    split: function(t1, t2) {
      // shortcuts
      if(t1===0 && !!t2) { return this.split(t2).left; }
      if(t2===1) { return this.split(t1).right; }

      // no shortcut: use "de Casteljau" iteration.
      var q = this.hull(t1);
      var result = {
        left: this.order === 2 ? new Bezier([q[0],q[3],q[5]]) : new Bezier([q[0],q[4],q[7],q[9]]),
        right: this.order === 2 ? new Bezier([q[5],q[4],q[2]]) : new Bezier([q[9],q[8],q[6],q[3]]),
        span: q
      };

      // make sure we bind _t1/_t2 information!
      result.left._t1  = utils.map(0,  0,1, this._t1,this._t2);
      result.left._t2  = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t1 = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t2 = utils.map(1,  0,1, this._t1,this._t2);

      // if we have no t2, we're done
      if(!t2) { return result; }

      // if we have a t2, split again:
      t2 = utils.map(t2,t1,1,0,1);
      var subsplit = result.right.split(t2);
      return subsplit.left;
    },
    extrema: function() {
      var dims = this.dims,
          result={},
          roots=[],
          p, mfn;
      dims.forEach(function(dim) {
        mfn = function(v) { return v[dim]; };
        p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if(this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function(t) { return (t>=0 && t<=1); });
        roots = roots.concat(result[dim].sort());
      }.bind(this));
      roots = roots.sort().filter(function(v,idx) { return (roots.indexOf(v) === idx); });
      result.values = roots;
      return result;
    },
    bbox: function() {
      var extrema = this.extrema(), result = {};
      this.dims.forEach(function(d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this));
      return result;
    },
    overlaps: function(curve) {
      var lbbox = this.bbox(),
          tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox,tbbox);
    },
    offset: function(t, d) {
      if(typeof d !== "undefined") {
        var c = this.get(t);
        var n = this.normal(t);
        var ret = {
          c: c,
          n: n,
          x: c.x + n.x * d,
          y: c.y + n.y * d
        };
        if(this._3d) {
          ret.z = c.z + n.z * d;
        };
        return ret;
      }
      if(this._linear) {
        var nv = this.normal(0);
        var coords = this.points.map(function(p) {
          var ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y
          };
          if(p.z && n.z) { ret.z = p.z + t * nv.z; }
          return ret;
        });
        return [new Bezier(coords)];
      }
      var reduced = this.reduce();
      return reduced.map(function(s) {
        return s.scale(t);
      });
    },
    simple: function() {
      if(this.order===3) {
        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if(a1>0 && a2<0 || a1<0 && a2>0) return false;
      }
      var n1 = this.normal(0);
      var n2 = this.normal(1);
      var s = n1.x*n2.x + n1.y*n2.y;
      if(this._3d) { s += n1.z*n2.z; }
      var angle = abs(acos(s));
      return angle < pi/3;
    },
    reduce: function() {
      var i, t1=0, t2=0, step=0.01, segment, pass1=[], pass2=[];
      // first pass: split on extrema
      var extrema = this.extrema().values;
      if(extrema.indexOf(0)===-1) { extrema = [0].concat(extrema); }
      if(extrema.indexOf(1)===-1) { extrema.push(1); }

      for(t1=extrema[0], i=1; i<extrema.length; i++) {
        t2 = extrema[i];
        segment = this.split(t1,t2);
        segment._t1 = t1;
        segment._t2 = t2;
        pass1.push(segment);
        t1 = t2;
      }

      // second pass: further reduce these segments to simple segments
      pass1.forEach(function(p1) {
        t1=0;
        t2=0;
        while(t2 <= 1) {
          for(t2=t1+step; t2<=1+step; t2+=step) {
            segment = p1.split(t1,t2);
            if(!segment.simple()) {
              t2 -= step;
              if(abs(t1-t2)<step) {
                // we can never form a reduction
                return [];
              }
              segment = p1.split(t1,t2);
              segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
              segment._t2 = utils.map(t2,0,1,p1._t1,p1._t2);
              pass2.push(segment);
              t1 = t2;
              break;
            }
          }
        }
        if(t1<1) {
          segment = p1.split(t1,1);
          segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    },
    scale: function(d) {
      var order = this.order;
      var distanceFn = false
      if(typeof d === "function") { distanceFn = d; }
      if(distanceFn && order === 2) { return this.raise().scale(distanceFn); }

      // TODO: add special handling for degenerate (=linear) curves.
      var clockwise = this.clockwise;
      var r1 = distanceFn ? distanceFn(0) : d;
      var r2 = distanceFn ? distanceFn(1) : d;
      var v = [ this.offset(0,10), this.offset(1,10) ];
      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
      if(!o) { throw new Error("cannot scale this curve. Try reducing it first."); }
      // move all points by distance 'd' wrt the origin 'o'
      var points=this.points, np=[];

      // move end points by fixed distance along normal.
      [0,1].forEach(function(t) {
        var p = np[t*order] = utils.copy(points[t*order]);
        p.x += (t?r2:r1) * v[t].n.x;
        p.y += (t?r2:r1) * v[t].n.y;
      }.bind(this));

      if (!distanceFn) {
        // move control points to lie on the intersection of the offset
        // derivative vector, and the origin-through-control vector
        [0,1].forEach(function(t) {
          if(this.order===2 && !!t) return;
          var p = np[t*order];
          var d = this.derivative(t);
          var p2 = { x: p.x + d.x, y: p.y + d.y };
          np[t+1] = utils.lli4(p, p2, o, points[t+1]);
        }.bind(this));
        return new Bezier(np);
      }

      // move control points by "however much necessary to
      // ensure the correct tangent to endpoint".
      [0,1].forEach(function(t) {
        if(this.order===2 && !!t) return;
        var p = points[t+1];
        var ov = {
          x: p.x - o.x,
          y: p.y - o.y
        };
        var rc = distanceFn ? distanceFn((t+1)/order) : d;
        if(distanceFn && !clockwise) rc = -rc;
        var m = sqrt(ov.x*ov.x + ov.y*ov.y);
        ov.x /= m;
        ov.y /= m;
        np[t+1] = {
          x: p.x + rc*ov.x,
          y: p.y + rc*ov.y
        }
      }.bind(this));
      return new Bezier(np);
    },
    outline: function(d1, d2, d3, d4) {
      d2 = (typeof d2 === "undefined") ? d1 : d2;
      var reduced = this.reduce(),
          len = reduced.length,
          fcurves = [],
          bcurves = [],
          p,
          alen = 0,
          tlen = this.length();

      var graduated = (typeof d3 !== "undefined" && typeof d4 !== "undefined");

      function linearDistanceFunction(s,e, tlen,alen,slen) {
        return function (v) {
          var f1 = alen/tlen, f2 = (alen+slen)/tlen, d = e-s;
          return utils.map(v, 0,1, s+f1*d, s+f2*d);
        };
      };

      // form curve oulines
      reduced.forEach(function(segment) {
        slen = segment.length();
        if (graduated) {
          fcurves.push(segment.scale(  linearDistanceFunction( d1, d3, tlen,alen,slen)  ));
          bcurves.push(segment.scale(  linearDistanceFunction(-d2,-d4, tlen,alen,slen)  ));
        } else {
          fcurves.push(segment.scale( d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });

      // reverse the "return" outline
      bcurves = bcurves.map(function(s) {
        p = s.points;
        if(p[3]) { s.points = [p[3],p[2],p[1],p[0]]; }
        else { s.points = [p[2],p[1],p[0]]; }
        return s;
      }).reverse();

      // form the endcaps as lines
      var fs = fcurves[0].points[0],
          fe = fcurves[len-1].points[fcurves[len-1].points.length-1],
          bs = bcurves[len-1].points[bcurves[len-1].points.length-1],
          be = bcurves[0].points[0],
          ls = utils.makeline(bs,fs),
          le = utils.makeline(fe,be),
          segments = [ls].concat(fcurves).concat([le]).concat(bcurves),
          slen = segments.length;

      return new PolyBezier(segments);
    },
    outlineshapes: function(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      var outline = this.outline(d1,d2).curves;
      var shapes = [];
      for(var i=1, len=outline.length; i < len/2; i++) {
        var shape = utils.makeshape(outline[i], outline[len-i], curveIntersectionThreshold);
        shape.startcap.virtual = (i > 1);
        shape.endcap.virtual = (i < len/2-1);
        shapes.push(shape);
      }
      return shapes;
    },
    intersects: function(curve, curveIntersectionThreshold) {
      if(!curve) return this.selfintersects(curveIntersectionThreshold);
      if(curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if(curve instanceof Bezier) { curve = curve.reduce(); }
      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
    },
    lineIntersects: function(line) {
      var mx = min(line.p1.x, line.p2.x),
          my = min(line.p1.y, line.p2.y),
          MX = max(line.p1.x, line.p2.x),
          MY = max(line.p1.y, line.p2.y),
          self=this;
      return utils.roots(this.points, line).filter(function(t) {
        var p = self.get(t);
        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
      });
    },
    selfintersects: function(curveIntersectionThreshold) {
      var reduced = this.reduce();
      // "simple" curves cannot intersect with their direct
      // neighbour, so for each segment X we check whether
      // it intersects [0:x-2][x+2:last].
      var i,len=reduced.length-2,results=[],result,left,right;
      for(i=0; i<len; i++) {
        left = reduced.slice(i,i+1);
        right = reduced.slice(i+2);
        result = this.curveintersects(left, right, curveIntersectionThreshold);
        results = results.concat( result );
      }
      return results;
    },
    curveintersects: function(c1, c2, curveIntersectionThreshold) {
      var pairs = [];
      // step 1: pair off any overlapping segments
      c1.forEach(function(l) {
        c2.forEach(function(r) {
          if(l.overlaps(r)) {
            pairs.push({ left: l, right: r });
          }
        });
      });
      // step 2: for each pairing, run through the convergence algorithm.
      var intersections = [];
      pairs.forEach(function(pair) {
        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
        if(result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    },
    arcs: function(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      var circles = [];
      return this._iterate(errorThreshold, circles);
    },
    _error: function(pc, np1, s, e) {
      var q = (e - s) / 4,
          c1 = this.get(s + q),
          c2 = this.get(e - q),
          ref = utils.dist(pc, np1),
          d1  = utils.dist(pc, c1),
          d2  = utils.dist(pc, c2);
      return abs(d1-ref) + abs(d2-ref);
    },
    _iterate: function(errorThreshold, circles) {
      var s = 0, e = 1, safety;
      // we do a binary search to find the "good `t` closest to no-longer-good"
      do {
        safety=0;

        // step 1: start with the maximum possible arc
        e = 1;

        // points:
        var np1 = this.get(s), np2, np3, arc, prev_arc;

        // booleans:
        var curr_good = false, prev_good = false, done;

        // numbers:
        var m = e, prev_e = 1, step = 0;

        // step 2: find the best possible arc
        do {
          prev_good = curr_good;
          prev_arc = arc;
          m = (s + e)/2;
          step++;

          np2 = this.get(m);
          np3 = this.get(e);

          arc = utils.getccenter(np1, np2, np3);

          //also save the t values
          arc.interval = {
            start: s,
            end: e
          };

          var error = this._error(arc, np1, s, e);
          curr_good = (error <= errorThreshold);

          done = prev_good && !curr_good;
          if(!done) prev_e = e;

          // this arc is fine: we can move 'e' up to see if we can find a wider arc
          if(curr_good) {

            // if e is already at max, then we're done for this arc.
            if (e >= 1) {
              arc.interval.end = prev_e = 1;
              prev_arc = arc;
              break;
            }
            // if not, move it up by half the iteration distance
            e = e + (e-s)/2;
          }

          // this is a bad arc: we need to move 'e' down to find a good arc
          else {
            e = m;
          }
        }
        while(!done && safety++<100);

        if(safety>=100) {
          break;
        }

        // console.log("L835: [F] arc found", s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

        prev_arc = (prev_arc ? prev_arc : arc);
        circles.push(prev_arc);
        s = prev_e;
      }
      while(e < 1);
      return circles;
    }
  };

  module.exports = Bezier;

}());

},{"./poly-bezier.js":20,"./utils.js":21}],20:[function(require,module,exports){
(function() {
  "use strict";

  var utils = require('./utils.js');

  /**
   * Poly Bezier
   * @param {[type]} curves [description]
   */
  var PolyBezier = function(curves) {
    this.curves = [];
    this._3d = false;
    if(!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  PolyBezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    },
    addCurve: function(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    },
    length: function() {
      return this.curves.map(function(v) { return v.length(); }).reduce(function(a,b) { return a+b; });
    },
    curve: function(idx) {
      return this.curves[idx];
    },
    bbox: function() {
      var c = this.curves;
      var bbox = c[0].bbox();
      for(var i=1; i<c.length; i++) {
        utils.expandbox(bbox, c[i].bbox());
      }
      return bbox;
    },
    offset: function(d) {
      var offset = [];
      this.curves.forEach(function(v) {
        offset = offset.concat(v.offset(d));
      });
      return new PolyBezier(offset);
    }
  };

  module.exports = PolyBezier;
}());

},{"./utils.js":21}],21:[function(require,module,exports){
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      acos = Math.acos,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // cube root function yielding real roots
      crt = function(v) { return (v<0) ? -pow(-v,1/3) : pow(v,1/3); },
      // trig constants
      pi = Math.PI,
      tau = 2*pi,
      quart = pi/2,
      // float precision significant decimal
      epsilon = 0.000001,
      // extremas used in bbox calculation and similar algorithms
      nMax = Number.MAX_SAFE_INTEGER,
      nMin = Number.MIN_SAFE_INTEGER;

  // Bezier utility functions
  var utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
       0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
       0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
       0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
       0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
       0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
       0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
       0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
       0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
       0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
       0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
       0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
       0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    between: function(v, m, M) {
      return (m <= v && v <= M) || utils.approximately(v, m) || utils.approximately(v, M);
    },

    approximately: function(a,b,precision) {
      return abs(a-b) <= (precision || epsilon);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=utils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * utils.Tvalues[i] + z;
        sum += utils.Cvalues[i] * utils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },

    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    // round as string, to avoid rounding errors
    round: function(v, d) {
      var s = '' + v;
      var pos = s.indexOf(".");
      return parseFloat(s.substring(0,pos+1+d));
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    closest: function(LUT, point) {
      var mdist = pow(2,63), mpos, d;
      LUT.forEach(function(p, idx) {
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          mpos = idx;
        }
      });
      return { mdist:mdist, mpos:mpos };
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    lli8: function(x1,y1,x2,y2,x3,y3,x4,y4) {
      var nx=(x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),
          ny=(x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4),
          d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if(d==0) { return false; }
      return { x: nx/d, y: ny/d };
    },

    lli4: function(p1,p2,p3,p4) {
      var x1 = p1.x, y1 = p1.y,
          x2 = p2.x, y2 = p2.y,
          x3 = p3.x, y3 = p3.y,
          x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1,y1,x2,y2,x3,y3,x4,y4);
    },

    lli: function(v1, v2) {
      return utils.lli4(v1,v1.c,v2,v2.c);
    },

    makeline: function(p1,p2) {
      var Bezier = require('./bezier');
      var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, dx = (x2-x1)/3, dy = (y2-y1)/3;
      return new Bezier(x1, y1, x1+dx, y1+dy, x1+2*dx, y1+2*dy, x2, y2);
    },

    findbbox: function(sections) {
      var mx=nMax,my=nMax,MX=nMin,MY=nMin;
      sections.forEach(function(s) {
        var bbox = s.bbox();
        if(mx > bbox.x.min) mx = bbox.x.min;
        if(my > bbox.y.min) my = bbox.y.min;
        if(MX < bbox.x.max) MX = bbox.x.max;
        if(MY < bbox.y.max) MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid:(mx+MX)/2, max: MX, size:MX-mx },
        y: { min: my, mid:(my+MY)/2, max: MY, size:MY-my }
      }
    },

    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if(!utils.bboxoverlap(bbox1, bbox2)) return [];
      var intersections = [];
      var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if(l1.virtual) return;
        a2.forEach(function(l2) {
          if(l2.virtual) return;
          var iss = l1.intersects(l2, curveIntersectionThreshold);
          if(iss.length>0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },

    makeshape: function(forward, back, curveIntersectionThreshold) {
      var bpl = back.points.length;
      var fpl = forward.points.length;
      var start  = utils.makeline(back.points[bpl-1], forward.points[0]);
      var end    = utils.makeline(forward.points[fpl-1], back.points[0]);
      var shape  = {
        startcap: start,
        forward: forward,
        back: back,
        endcap: end,
        bbox: utils.findbbox([start, forward, back, end])
      };
      var self = utils;
      shape.intersections = function(s2) {
        return self.shapeintersections(shape,shape.bbox,s2,s2.bbox, curveIntersectionThreshold);
      };
      return shape;
    },

    getminmax: function(curve, d, list) {
      if(!list) return { min:0, max:0 };
      var min=nMax, max=nMin,t,c;
      if(list.indexOf(0)===-1) { list = [0].concat(list); }
      if(list.indexOf(1)===-1) { list.push(1); }
      for(var i=0,len=list.length; i<len; i++) {
        t = list[i];
        c = curve.get(t);
        if(c[d] < min) { min = c[d]; }
        if(c[d] > max) { max = c[d]; }
      }
      return { min:min, mid:(min+max)/2, max:max, size:max-min };
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    },

    roots: function(points, line) {
      line = line || {p1:{x:0,y:0},p2:{x:1,y:0}};
      var order = points.length - 1;
      var p = utils.align(points, line);
      var reduce = function(t) { return 0<=t && t <=1; };

      if (order === 2) {
        var a = p[0].y,
            b = p[1].y,
            c = p[2].y,
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2].filter(reduce);
        }
        else if(b!==c && d===0) {
          return [ (2*b-c)/2*(b-c) ].filter(reduce);
        }
        return [];
      }

      // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
      var pa = p[0].y,
          pb = p[1].y,
          pc = p[2].y,
          pd = p[3].y,
          d = (-pa + 3*pb - 3*pc + pd),
          a = (3*pa - 6*pb + 3*pc) / d,
          b = (-3*pa + 3*pb) / d,
          c = pa / d,
          p = (3*b - a*a)/3,
          p3 = p/3,
          q = (2*a*a*a - 9*a*b + 27*c)/27,
          q2 = q/2,
          discriminant = q2*q2 + p3*p3*p3,
          u1,v1,x1,x2,x3;
       if (discriminant < 0) {
        var mp3 = -p/3,
            mp33 = mp3*mp3*mp3,
            r = sqrt( mp33 ),
            t = -q/(2*r),
            cosphi = t<-1 ? -1 : t>1 ? 1 : t,
            phi = acos(cosphi),
            crtr = crt(r),
            t1 = 2*crtr;
        x1 = t1 * cos(phi/3) - a/3;
        x2 = t1 * cos((phi+tau)/3) - a/3;
        x3 = t1 * cos((phi+2*tau)/3) - a/3;
        return [x1, x2, x3].filter(reduce);
      } else if(discriminant === 0) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2*u1-a/3;
        x2 = -u1 - a/3;
        return [x1,x2].filter(reduce);
      } else {
        var sd = sqrt(discriminant);
        u1 = crt(-q2+sd);
        v1 = crt(q2+sd);
        return [u1-v1-a/3].filter(reduce);;
      }
    },

    droots: function(p) {
      // quadratic roots are easy
      if(p.length === 3) {
        var a = p[0],
            b = p[1],
            c = p[2],
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2];
        }
        else if(b!==c && d===0) {
          return [(2*b-c)/(2*(b-c))];
        }
        return [];
      }

      // linear roots are even easier
      if(p.length === 2) {
        var a = p[0], b = p[1];
        if(a!==b) {
          return [a/(a-b)];
        }
        return [];
      }
    },

    inflections: function(points) {
      if (points.length<4) return [];

      // FIXME: TODO: add in inflection abstraction for quartic+ curves?

      var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
          a = p[2].x * p[1].y,
          b = p[3].x * p[1].y,
          c = p[1].x * p[2].y,
          d = p[3].x * p[2].y,
          v1 = 18 * (-3*a + 2*b + 3*c - d),
          v2 = 18 * (3*a - b - 3*c),
          v3 = 18 * (c - a);

      if (utils.approximately(v1,0)){
        if(!utils.approximately(v2,0)){
          var t = -v3/v2;
          if (0 <= t && t <= 1)
             return [t];
        }
        return [];
      }

      var trm = v2*v2 - 4*v1*v3,
          sq = Math.sqrt(trm),
          d = 2 * v1;

      if (utils.approximately(d,0)) return [];

      return [(sq-v2)/d, -(v2+sq)/d].filter(function(r) {
        return (0 <= r && r <= 1);
      });
    },

    bboxoverlap: function(b1,b2) {
      var dims=['x','y'],len=dims.length,i,dim,l,t,d
      for(i=0; i<len; i++) {
        dim = dims[i];
        l = b1[dim].mid;
        t = b2[dim].mid;
        d = (b1[dim].size + b2[dim].size)/2;
        if(abs(l-t) >= d) return false;
      }
      return true;
    },

    expandbox: function(bbox, _bbox) {
      if(_bbox.x.min < bbox.x.min) { bbox.x.min = _bbox.x.min; }
      if(_bbox.y.min < bbox.y.min) { bbox.y.min = _bbox.y.min; }
      if(_bbox.z && _bbox.z.min < bbox.z.min) { bbox.z.min = _bbox.z.min; }
      if(_bbox.x.max > bbox.x.max) { bbox.x.max = _bbox.x.max; }
      if(_bbox.y.max > bbox.y.max) { bbox.y.max = _bbox.y.max; }
      if(_bbox.z && _bbox.z.max > bbox.z.max) { bbox.z.max = _bbox.z.max; }
      bbox.x.mid = (bbox.x.min + bbox.x.max)/2;
      bbox.y.mid = (bbox.y.min + bbox.y.max)/2;
      if(bbox.z) { bbox.z.mid = (bbox.z.min + bbox.z.max)/2; }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if(bbox.z) { bbox.z.size = bbox.z.max - bbox.z.min; }
    },

    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      var c1b = c1.bbox(),
          c2b = c2.bbox(),
          r = 100000,
          threshold = curveIntersectionThreshold || 0.5;
      if(c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [ ((r * (c1._t1+c1._t2)/2)|0)/r + "/" + ((r * (c2._t1+c2._t2)/2)|0)/r ];
      }
      var cc1 = c1.split(0.5),
          cc2 = c2.split(0.5),
          pairs = [
            {left: cc1.left, right: cc2.left },
            {left: cc1.left, right: cc2.right },
            {left: cc1.right, right: cc2.right },
            {left: cc1.right, right: cc2.left }];
      pairs = pairs.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(),pair.right.bbox());
      });
      var results = [];
      if(pairs.length === 0) return results;
      pairs.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      })
      results = results.filter(function(v,i) {
        return results.indexOf(v) === i;
      });
      return results;
    },

    getccenter: function(p1,p2,p3) {
      var dx1 = (p2.x - p1.x),
          dy1 = (p2.y - p1.y),
          dx2 = (p3.x - p2.x),
          dy2 = (p3.y - p2.y);
      var dx1p = dx1 * cos(quart) - dy1 * sin(quart),
          dy1p = dx1 * sin(quart) + dy1 * cos(quart),
          dx2p = dx2 * cos(quart) - dy2 * sin(quart),
          dy2p = dx2 * sin(quart) + dy2 * cos(quart);
      // chord midpoints
      var mx1 = (p1.x + p2.x)/2,
          my1 = (p1.y + p2.y)/2,
          mx2 = (p2.x + p3.x)/2,
          my2 = (p2.y + p3.y)/2;
      // midpoint offsets
      var mx1n = mx1 + dx1p,
          my1n = my1 + dy1p,
          mx2n = mx2 + dx2p,
          my2n = my2 + dy2p;
      // intersection of these lines:
      var arc = utils.lli8(mx1,my1,mx1n,my1n, mx2,my2,mx2n,my2n),
          r = utils.dist(arc,p1),
          // arc start/end values, over mid point:
          s = atan2(p1.y - arc.y, p1.x - arc.x),
          m = atan2(p2.y - arc.y, p2.x - arc.x),
          e = atan2(p3.y - arc.y, p3.x - arc.x),
          _;
      // determine arc direction (cw/ccw correction)
      if (s<e) {
        // if s<m<e, arc(s, e)
        // if m<s<e, arc(e, s + tau)
        // if s<e<m, arc(e, s + tau)
        if (s>m || m>e) { s += tau; }
        if (s>e) { _=e; e=s; s=_; }
      } else {
        // if e<m<s, arc(e, s)
        // if m<e<s, arc(s, e + tau)
        // if e<s<m, arc(s, e + tau)
        if (e<m && m<s) { _=e; e=s; s=_; } else { e += tau; }
      }
      // assign and done.
      arc.s = s;
      arc.e = e;
      arc.r = r;
      return arc;
    }
  };

  module.exports = utils;
}());

},{"./bezier":19}],22:[function(require,module,exports){
exports = module.exports = Victor;

/**
 * # Victor - A JavaScript 2D vector class with methods for common vector operations
 */

/**
 * Constructor. Will also work without the `new` keyword
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = Victor(42, 1337);
 *
 * @param {Number} x Value of the x axis
 * @param {Number} y Value of the y axis
 * @return {Victor}
 * @api public
 */
function Victor (x, y) {
	if (!(this instanceof Victor)) {
		return new Victor(x, y);
	}

	/**
	 * The X axis
	 *
	 * ### Examples:
	 *     var vec = new Victor.fromArray(42, 21);
	 *
	 *     vec.x;
	 *     // => 42
	 *
	 * @api public
	 */
	this.x = x || 0;

	/**
	 * The Y axis
	 *
	 * ### Examples:
	 *     var vec = new Victor.fromArray(42, 21);
	 *
	 *     vec.y;
	 *     // => 21
	 *
	 * @api public
	 */
	this.y = y || 0;
};

/**
 * # Static
 */

/**
 * Creates a new instance from an array
 *
 * ### Examples:
 *     var vec = Victor.fromArray([42, 21]);
 *
 *     vec.toString();
 *     // => x:42, y:21
 *
 * @name Victor.fromArray
 * @param {Array} array Array with the x and y values at index 0 and 1 respectively
 * @return {Victor} The new instance
 * @api public
 */
Victor.fromArray = function (arr) {
	return new Victor(arr[0] || 0, arr[1] || 0);
};

/**
 * Creates a new instance from an object
 *
 * ### Examples:
 *     var vec = Victor.fromObject({ x: 42, y: 21 });
 *
 *     vec.toString();
 *     // => x:42, y:21
 *
 * @name Victor.fromObject
 * @param {Object} obj Object with the values for x and y
 * @return {Victor} The new instance
 * @api public
 */
Victor.fromObject = function (obj) {
	return new Victor(obj.x || 0, obj.y || 0);
};

/**
 * # Manipulation
 *
 * These functions are chainable.
 */

/**
 * Adds another vector's X axis to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.addX(vec2);
 *     vec1.toString();
 *     // => x:30, y:10
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.addX = function (vec) {
	this.x += vec.x;
	return this;
};

/**
 * Adds another vector's Y axis to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.addY(vec2);
 *     vec1.toString();
 *     // => x:10, y:40
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.addY = function (vec) {
	this.y += vec.y;
	return this;
};

/**
 * Adds another vector to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.add(vec2);
 *     vec1.toString();
 *     // => x:30, y:40
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.add = function (vec) {
	this.x += vec.x;
	this.y += vec.y;
	return this;
};

/**
 * Adds the given scalar to both vector axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalar(2);
 *     vec.toString();
 *     // => x: 3, y: 4
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.addScalar = function (scalar) {
	this.x += scalar;
	this.y += scalar;
	return this;
};

/**
 * Adds the given scalar to the X axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalarX(2);
 *     vec.toString();
 *     // => x: 3, y: 2
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.addScalarX = function (scalar) {
	this.x += scalar;
	return this;
};

/**
 * Adds the given scalar to the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalarY(2);
 *     vec.toString();
 *     // => x: 1, y: 4
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.addScalarY = function (scalar) {
	this.y += scalar;
	return this;
};

/**
 * Subtracts the X axis of another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtractX(vec2);
 *     vec1.toString();
 *     // => x:80, y:50
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtractX = function (vec) {
	this.x -= vec.x;
	return this;
};

/**
 * Subtracts the Y axis of another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtractY(vec2);
 *     vec1.toString();
 *     // => x:100, y:20
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtractY = function (vec) {
	this.y -= vec.y;
	return this;
};

/**
 * Subtracts another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtract(vec2);
 *     vec1.toString();
 *     // => x:80, y:20
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtract = function (vec) {
	this.x -= vec.x;
	this.y -= vec.y;
	return this;
};

/**
 * Subtracts the given scalar from both axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalar(20);
 *     vec.toString();
 *     // => x: 80, y: 180
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtractScalar = function (scalar) {
	this.x -= scalar;
	this.y -= scalar;
	return this;
};

/**
 * Subtracts the given scalar from the X axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalarX(20);
 *     vec.toString();
 *     // => x: 80, y: 200
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtractScalarX = function (scalar) {
	this.x -= scalar;
	return this;
};

/**
 * Subtracts the given scalar from the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalarY(20);
 *     vec.toString();
 *     // => x: 100, y: 180
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.subtractScalarY = function (scalar) {
	this.y -= scalar;
	return this;
};

/**
 * Divides the X axis by the x component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 0);
 *
 *     vec.divideX(vec2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Victor} vector The other vector you want divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divideX = function (vector) {
	this.x /= vector.x;
	return this;
};

/**
 * Divides the Y axis by the y component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(0, 2);
 *
 *     vec.divideY(vec2);
 *     vec.toString();
 *     // => x:100, y:25
 *
 * @param {Victor} vector The other vector you want divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divideY = function (vector) {
	this.y /= vector.y;
	return this;
};

/**
 * Divides both vector axis by a axis values of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 2);
 *
 *     vec.divide(vec2);
 *     vec.toString();
 *     // => x:50, y:25
 *
 * @param {Victor} vector The vector to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divide = function (vector) {
	this.x /= vector.x;
	this.y /= vector.y;
	return this;
};

/**
 * Divides both vector axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalar(2);
 *     vec.toString();
 *     // => x:50, y:25
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divideScalar = function (scalar) {
	if (scalar !== 0) {
		this.x /= scalar;
		this.y /= scalar;
	} else {
		this.x = 0;
		this.y = 0;
	}

	return this;
};

/**
 * Divides the X axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalarX(2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divideScalarX = function (scalar) {
	if (scalar !== 0) {
		this.x /= scalar;
	} else {
		this.x = 0;
	}
	return this;
};

/**
 * Divides the Y axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalarY(2);
 *     vec.toString();
 *     // => x:100, y:25
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.divideScalarY = function (scalar) {
	if (scalar !== 0) {
		this.y /= scalar;
	} else {
		this.y = 0;
	}
	return this;
};

/**
 * Inverts the X axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invertX();
 *     vec.toString();
 *     // => x:-100, y:50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.invertX = function () {
	this.x *= -1;
	return this;
};

/**
 * Inverts the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invertY();
 *     vec.toString();
 *     // => x:100, y:-50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.invertY = function () {
	this.y *= -1;
	return this;
};

/**
 * Inverts both axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invert();
 *     vec.toString();
 *     // => x:-100, y:-50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.invert = function () {
	this.invertX();
	this.invertY();
	return this;
};

/**
 * Multiplies the X axis by X component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 0);
 *
 *     vec.multiplyX(vec2);
 *     vec.toString();
 *     // => x:200, y:50
 *
 * @param {Victor} vector The vector to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiplyX = function (vector) {
	this.x *= vector.x;
	return this;
};

/**
 * Multiplies the Y axis by Y component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(0, 2);
 *
 *     vec.multiplyX(vec2);
 *     vec.toString();
 *     // => x:100, y:100
 *
 * @param {Victor} vector The vector to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiplyY = function (vector) {
	this.y *= vector.y;
	return this;
};

/**
 * Multiplies both vector axis by values from a given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 2);
 *
 *     vec.multiply(vec2);
 *     vec.toString();
 *     // => x:200, y:100
 *
 * @param {Victor} vector The vector to multiply by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiply = function (vector) {
	this.x *= vector.x;
	this.y *= vector.y;
	return this;
};

/**
 * Multiplies both vector axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalar(2);
 *     vec.toString();
 *     // => x:200, y:100
 *
 * @param {Number} The scalar to multiply by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiplyScalar = function (scalar) {
	this.x *= scalar;
	this.y *= scalar;
	return this;
};

/**
 * Multiplies the X axis by the given scalar
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalarX(2);
 *     vec.toString();
 *     // => x:200, y:50
 *
 * @param {Number} The scalar to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiplyScalarX = function (scalar) {
	this.x *= scalar;
	return this;
};

/**
 * Multiplies the Y axis by the given scalar
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalarY(2);
 *     vec.toString();
 *     // => x:100, y:100
 *
 * @param {Number} The scalar to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.multiplyScalarY = function (scalar) {
	this.y *= scalar;
	return this;
};

/**
 * Normalize
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.normalize = function () {
	var length = this.length();

	if (length === 0) {
		this.x = 1;
		this.y = 0;
	} else {
		this.divide(Victor(length, length));
	}
	return this;
};

Victor.prototype.norm = Victor.prototype.normalize;

/**
 * If the absolute vector axis is greater than `max`, multiplies the axis by `factor`
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.limit(80, 0.9);
 *     vec.toString();
 *     // => x:90, y:50
 *
 * @param {Number} max The maximum value for both x and y axis
 * @param {Number} factor Factor by which the axis are to be multiplied with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.limit = function (max, factor) {
	if (Math.abs(this.x) > max){ this.x *= factor; }
	if (Math.abs(this.y) > max){ this.y *= factor; }
	return this;
};

/**
 * Randomizes both vector axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomize(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:67, y:73
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.randomize = function (topLeft, bottomRight) {
	this.randomizeX(topLeft, bottomRight);
	this.randomizeY(topLeft, bottomRight);

	return this;
};

/**
 * Randomizes the y axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeX(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:55, y:50
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.randomizeX = function (topLeft, bottomRight) {
	var min = Math.min(topLeft.x, bottomRight.x);
	var max = Math.max(topLeft.x, bottomRight.x);
	this.x = random(min, max);
	return this;
};

/**
 * Randomizes the y axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeY(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:100, y:66
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.randomizeY = function (topLeft, bottomRight) {
	var min = Math.min(topLeft.y, bottomRight.y);
	var max = Math.max(topLeft.y, bottomRight.y);
	this.y = random(min, max);
	return this;
};

/**
 * Randomly randomizes either axis between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeAny(new Victor(50, 60), new Victor(70, 80));
 *     vec.toString();
 *     // => x:100, y:77
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.randomizeAny = function (topLeft, bottomRight) {
	if (!! Math.round(Math.random())) {
		this.randomizeX(topLeft, bottomRight);
	} else {
		this.randomizeY(topLeft, bottomRight);
	}
	return this;
};

/**
 * Rounds both axis to an integer value
 *
 * ### Examples:
 *     var vec = new Victor(100.2, 50.9);
 *
 *     vec.unfloat();
 *     vec.toString();
 *     // => x:100, y:51
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.unfloat = function () {
	this.x = Math.round(this.x);
	this.y = Math.round(this.y);
	return this;
};

/**
 * Rounds both axis to a certain precision
 *
 * ### Examples:
 *     var vec = new Victor(100.2, 50.9);
 *
 *     vec.unfloat();
 *     vec.toString();
 *     // => x:100, y:51
 *
 * @param {Number} Precision (default: 8)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.toFixed = function (precision) {
	if (typeof precision === 'undefined') { precision = 8; }
	this.x = this.x.toFixed(precision);
	this.y = this.y.toFixed(precision);
	return this;
};

/**
 * Performs a linear blend / interpolation of the X axis towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mixX(vec2, 0.5);
 *     vec.toString();
 *     // => x:150, y:100
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.mixX = function (vec, amount) {
	if (typeof amount === 'undefined') {
		amount = 0.5;
	}

	this.x = (1 - amount) * this.x + amount * vec.x;
	return this;
};

/**
 * Performs a linear blend / interpolation of the Y axis towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mixY(vec2, 0.5);
 *     vec.toString();
 *     // => x:100, y:150
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.mixY = function (vec, amount) {
	if (typeof amount === 'undefined') {
		amount = 0.5;
	}

	this.y = (1 - amount) * this.y + amount * vec.y;
	return this;
};

/**
 * Performs a linear blend / interpolation towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mix(vec2, 0.5);
 *     vec.toString();
 *     // => x:150, y:150
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.mix = function (vec, amount) {
	this.mixX(vec, amount);
	this.mixY(vec, amount);
	return this;
};

/**
 * # Products
 */

/**
 * Creates a clone of this vector
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = vec1.clone();
 *
 *     vec2.toString();
 *     // => x:10, y:10
 *
 * @return {Victor} A clone of the vector
 * @api public
 */
Victor.prototype.clone = function () {
	return new Victor(this.x, this.y);
};

/**
 * Copies another vector's X component in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copyX(vec1);
 *
 *     vec2.toString();
 *     // => x:20, y:10
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.copyX = function (vec) {
	this.x = vec.x;
	return this;
};

/**
 * Copies another vector's Y component in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copyY(vec1);
 *
 *     vec2.toString();
 *     // => x:10, y:20
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.copyY = function (vec) {
	this.y = vec.y;
	return this;
};

/**
 * Copies another vector's X and Y components in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copy(vec1);
 *
 *     vec2.toString();
 *     // => x:20, y:20
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.copy = function (vec) {
	this.copyX(vec);
	this.copyY(vec);
	return this;
};

/**
 * Sets the vector to zero (0,0)
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *		 var1.zero();
 *     vec1.toString();
 *     // => x:0, y:0
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.zero = function () {
	this.x = this.y = 0;
	return this;
};

/**
 * Calculates the dot product of this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.dot(vec2);
 *     // => 23000
 *
 * @param {Victor} vector The second vector
 * @return {Number} Dot product
 * @api public
 */
Victor.prototype.dot = function (vec2) {
	return this.x * vec2.x + this.y * vec2.y;
};

Victor.prototype.cross = function (vec2) {
	return (this.x * vec2.y ) - (this.y * vec2.x );
};

/**
 * Projects a vector onto another vector, setting itself to the result.
 *
 * ### Examples:
 *     var vec = new Victor(100, 0);
 *     var vec2 = new Victor(100, 100);
 *
 *     vec.projectOnto(vec2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Victor} vector The other vector you want to project this vector onto
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
Victor.prototype.projectOnto = function (vec2) {
    var coeff = ( (this.x * vec2.x)+(this.y * vec2.y) ) / ((vec2.x*vec2.x)+(vec2.y*vec2.y));
    this.x = coeff * vec2.x;
    this.y = coeff * vec2.y;
    return this;
};


Victor.prototype.horizontalAngle = function () {
	return Math.atan2(this.y, this.x);
};

Victor.prototype.horizontalAngleDeg = function () {
	return radian2degrees(this.horizontalAngle());
};

Victor.prototype.verticalAngle = function () {
	return Math.atan2(this.x, this.y);
};

Victor.prototype.verticalAngleDeg = function () {
	return radian2degrees(this.verticalAngle());
};

Victor.prototype.angle = Victor.prototype.horizontalAngle;
Victor.prototype.angleDeg = Victor.prototype.horizontalAngleDeg;
Victor.prototype.direction = Victor.prototype.horizontalAngle;

Victor.prototype.rotate = function (angle) {
	var nx = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));
	var ny = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));

	this.x = nx;
	this.y = ny;

	return this;
};

Victor.prototype.rotateDeg = function (angle) {
	angle = degrees2radian(angle);
	return this.rotate(angle);
};

Victor.prototype.rotateTo = function(rotation) {
	return this.rotate(rotation-this.angle());
};

Victor.prototype.rotateToDeg = function(rotation) {
	rotation = degrees2radian(rotation);
	return this.rotateTo(rotation);
};

Victor.prototype.rotateBy = function (rotation) {
	var angle = this.angle() + rotation;

	return this.rotate(angle);
};

Victor.prototype.rotateByDeg = function (rotation) {
	rotation = degrees2radian(rotation);
	return this.rotateBy(rotation);
};

/**
 * Calculates the distance of the X axis between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceX(vec2);
 *     // => -100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
Victor.prototype.distanceX = function (vec) {
	return this.x - vec.x;
};

/**
 * Same as `distanceX()` but always returns an absolute number
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.absDistanceX(vec2);
 *     // => 100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Absolute distance
 * @api public
 */
Victor.prototype.absDistanceX = function (vec) {
	return Math.abs(this.distanceX(vec));
};

/**
 * Calculates the distance of the Y axis between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceY(vec2);
 *     // => -10
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
Victor.prototype.distanceY = function (vec) {
	return this.y - vec.y;
};

/**
 * Same as `distanceY()` but always returns an absolute number
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceY(vec2);
 *     // => 10
 *
 * @param {Victor} vector The second vector
 * @return {Number} Absolute distance
 * @api public
 */
Victor.prototype.absDistanceY = function (vec) {
	return Math.abs(this.distanceY(vec));
};

/**
 * Calculates the euclidean distance between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distance(vec2);
 *     // => 100.4987562112089
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
Victor.prototype.distance = function (vec) {
	return Math.sqrt(this.distanceSq(vec));
};

/**
 * Calculates the squared euclidean distance between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceSq(vec2);
 *     // => 10100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
Victor.prototype.distanceSq = function (vec) {
	var dx = this.distanceX(vec),
		dy = this.distanceY(vec);

	return dx * dx + dy * dy;
};

/**
 * Calculates the length or magnitude of the vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.length();
 *     // => 111.80339887498948
 *
 * @return {Number} Length / Magnitude
 * @api public
 */
Victor.prototype.length = function () {
	return Math.sqrt(this.lengthSq());
};

/**
 * Squared length / magnitude
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.lengthSq();
 *     // => 12500
 *
 * @return {Number} Length / Magnitude
 * @api public
 */
Victor.prototype.lengthSq = function () {
	return this.x * this.x + this.y * this.y;
};

Victor.prototype.magnitude = Victor.prototype.length;

/**
 * Returns a true if vector is (0, 0)
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     vec.zero();
 *
 *     // => true
 *
 * @return {Boolean}
 * @api public
 */
Victor.prototype.isZero = function() {
	return this.x === 0 && this.y === 0;
};

/**
 * Returns a true if this vector is the same as another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(100, 50);
 *     vec1.isEqualTo(vec2);
 *
 *     // => true
 *
 * @return {Boolean}
 * @api public
 */
Victor.prototype.isEqualTo = function(vec2) {
	return this.x === vec2.x && this.y === vec2.y;
};

/**
 * # Utility Methods
 */

/**
 * Returns an string representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toString();
 *     // => x:10, y:20
 *
 * @return {String}
 * @api public
 */
Victor.prototype.toString = function () {
	return 'x:' + this.x + ', y:' + this.y;
};

/**
 * Returns an array representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toArray();
 *     // => [10, 20]
 *
 * @return {Array}
 * @api public
 */
Victor.prototype.toArray = function () {
	return [ this.x, this.y ];
};

/**
 * Returns an object representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toObject();
 *     // => { x: 10, y: 20 }
 *
 * @return {Object}
 * @api public
 */
Victor.prototype.toObject = function () {
	return { x: this.x, y: this.y };
};


var degrees = 180 / Math.PI;

function random (min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

function radian2degrees (rad) {
	return rad * degrees;
}

function degrees2radian (deg) {
	return deg / degrees;
}

},{}],23:[function(require,module,exports){
const victor = require('victor');

const bm = require('../../helpers/BucketMechanics');
const om = require('../../helpers/OrbitalMechanics');
const nm = require('../../helpers/NavigationMechanics');
const qm = require('../../helpers/QuestMechanics');
const db = require('../../data/DataBox');
const md = require('../../helpers/MapData');

SolGame.Shared = {
	Victor : victor,
	
	BucketMechanics : bm,
	OrbitalMechanics : om,
	NavigationMechanics : nm,
	QuestMechanics : qm,
	DataBox : db,
	MapData : md
};

},{"../../data/DataBox":6,"../../helpers/BucketMechanics":11,"../../helpers/MapData":13,"../../helpers/NavigationMechanics":14,"../../helpers/OrbitalMechanics":15,"../../helpers/QuestMechanics":17,"victor":22}]},{},[23]);
